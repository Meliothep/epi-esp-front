{
  "version": 3,
  "sources": ["../../../dev/core/src/PostProcesses/thinBlurPostProcess.ts", "../../../dev/core/src/PostProcesses/blurPostProcess.ts", "../../../dev/core/src/Layers/thinHighlightLayer.ts", "../../../dev/core/src/Layers/highlightLayer.ts"],
  "sourcesContent": ["// eslint-disable-next-line import/no-internal-modules\r\nimport type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Vector2, Effect } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to apply a blur effect\r\n */\r\nexport class ThinBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The vertex shader url\r\n     */\r\n    public static readonly VertexUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"delta\", \"direction\"];\r\n\r\n    /**\r\n     * The list of samplers used by the effect\r\n     */\r\n    public static readonly Samplers = [\"circleOfConfusionSampler\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/kernelBlur.fragment\"), import(\"../ShadersWGSL/kernelBlur.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/kernelBlur.fragment\"), import(\"../Shaders/kernelBlur.vertex\")]));\r\n        }\r\n    }\r\n\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /**\r\n     * Constructs a new blur post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param direction Direction in which to apply the blur\r\n     * @param kernel Kernel size of the blur\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, direction?: Vector2, kernel?: number, options?: EffectWrapperCreationOptions) {\r\n        const blockCompilationFinal = !!options?.blockCompilation;\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            blockCompilation: true,\r\n        });\r\n\r\n        this.options.blockCompilation = blockCompilationFinal;\r\n\r\n        if (direction !== undefined) {\r\n            this.direction = direction;\r\n        }\r\n        if (kernel !== undefined) {\r\n            this.kernel = kernel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the blur on\r\n     */\r\n    public textureWidth: number = 0;\r\n\r\n    /**\r\n     * Height of the texture to apply the blur on\r\n     */\r\n    public textureHeight: number = 0;\r\n\r\n    /** The direction in which to blur the image. */\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    public override bind() {\r\n        super.bind();\r\n        this._drawWrapper.effect!.setFloat2(\"delta\", (1 / this.textureWidth) * this.direction.x, (1 / this.textureHeight) * this.direction.y);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === ShaderLanguage.WGSL ? 1 : 0); // Because of the additional builtins\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this.options.blockCompilation = false;\r\n\r\n        this.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n}\r\n", "import type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinBlurPostProcess } from \"./thinBlurPostProcess\";\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public get direction() {\r\n        return this._effectWrapper.direction;\r\n    }\r\n\r\n    public set direction(value: Vector2) {\r\n        this._effectWrapper.direction = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    @serialize()\r\n    public set kernel(v: number) {\r\n        this._effectWrapper.kernel = v;\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._effectWrapper.kernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    @serialize()\r\n    public set packedFloat(v: boolean) {\r\n        this._effectWrapper.packedFloat = v;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._effectWrapper.packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinBlurPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        defines = \"\",\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        const blockCompilationFinal = typeof options === \"number\" ? blockCompilation : !!options.blockCompilation;\r\n        const localOptions = {\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            indexParameters: { varyingCount: 0, depCount: 0 },\r\n            textureFormat,\r\n            defines,\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinBlurPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinBlurPostProcess(name, engine, undefined, undefined, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this._effectWrapper.options.blockCompilation = blockCompilationFinal;\r\n\r\n        this.direction = direction;\r\n        this.onApplyObservable.add(() => {\r\n            this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;\r\n            this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    public override updateEffect(\r\n        _defines: Nullable<string> = null,\r\n        _uniforms: Nullable<string[]> = null,\r\n        _samplers: Nullable<string[]> = null,\r\n        _indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._effectWrapper._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n", "import type {\r\n    Observer,\r\n    Nullable,\r\n    Scene,\r\n    SubMesh,\r\n    AbstractMesh,\r\n    Mesh,\r\n    Effect,\r\n    IThinEffectLayerOptions,\r\n    Color3,\r\n    EffectWrapper,\r\n    // eslint-disable-next-line import/no-internal-modules\r\n} from \"core/index\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ThinPassPostProcess } from \"../PostProcesses/thinPassPostProcess\";\r\nimport { ThinEffectLayer, ThinGlowBlurPostProcess } from \"./thinEffectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\n\r\ninterface IBlurPostProcess extends EffectWrapper {\r\n    kernel: number;\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IThinHighlightLayerOptions extends IThinEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size\r\n     * of the picture to blur (the smaller the faster). Default: 0.5\r\n     */\r\n    blurTextureSizeRatio?: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the vertical blur. Default: 1\r\n     */\r\n    blurVerticalSize?: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the horizontal blur. Default: 1\r\n     */\r\n    blurHorizontalSize?: number;\r\n\r\n    /**\r\n     * Should we display highlight as a solid stroke? Default: false\r\n     */\r\n    isStroke?: boolean;\r\n\r\n    /**\r\n     * Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    forceGLSL?: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for glowing a mesh.\r\n */\r\ninterface IHighlightLayerMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The color of the glow\r\n     */\r\n    color: Color3;\r\n    /**\r\n     * The mesh render callback use to insert stencil information\r\n     */\r\n    observerHighlight: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to come to the default behavior\r\n     */\r\n    observerDefault: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * If it exists, the emissive color of the material will be used to generate the glow.\r\n     * Else it falls back to the current color.\r\n     */\r\n    glowEmissiveOnly: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for an excluded mesh.\r\n */\r\ninterface IHighlightLayerExcludedMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The mesh render callback use to prevent stencil use\r\n     */\r\n    beforeBind: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to restore previous stencil use\r\n     */\r\n    afterRender: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * Current stencil state of the engine\r\n     */\r\n    stencilState: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinHighlightLayer extends ThinEffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static NeutralColor: Color4 = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Stencil value used for glowing meshes.\r\n     */\r\n    public static GlowingMeshStencilReference = 0x02;\r\n\r\n    /**\r\n     * Stencil value used for the other meshes in the scene.\r\n     */\r\n    public static NormalMeshStencilReference = 0x01;\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    public innerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    public outerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._horizontalBlurPostprocess.kernel = value;\r\n        this._options.blurHorizontalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._verticalBlurPostprocess.kernel = value;\r\n        this._options.blurVerticalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    public get blurHorizontalSize(): number {\r\n        return this._horizontalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    public get blurVerticalSize(): number {\r\n        return this._verticalBlurPostprocess.kernel;\r\n    }\r\n\r\n    private _instanceGlowingMeshStencilReference = ThinHighlightLayer.GlowingMeshStencilReference++;\r\n\r\n    /** @internal */\r\n    public override _options: Required<IThinHighlightLayerOptions>;\r\n\r\n    private _downSamplePostprocess: ThinPassPostProcess;\r\n    private _horizontalBlurPostprocess: IBlurPostProcess;\r\n    private _verticalBlurPostprocess: IBlurPostProcess;\r\n\r\n    /** @internal */\r\n    public _meshes: Nullable<{ [id: string]: Nullable<IHighlightLayerMesh> }> = {};\r\n    /** @internal */\r\n    public _excludedMeshes: Nullable<{ [id: string]: Nullable<IHighlightLayerExcludedMesh> }> = {};\r\n\r\n    /** @internal */\r\n    public _mainObjectRendererRenderPassId = -1;\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IThinHighlightLayerOptions>, dontCheckIfReady = false) {\r\n        super(name, scene, options !== undefined ? !!options.forceGLSL : false);\r\n\r\n        this.neutralColor = ThinHighlightLayer.NeutralColor;\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            forceGLSL: false,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            isStroke: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n\r\n        if (dontCheckIfReady) {\r\n            // When dontCheckIfReady is true, we are in the new ThinXXX layer mode, so we must call _createTextureAndPostProcesses ourselves (it is called by EffectLayer otherwise)\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    protected override async _importShadersAsync() {\r\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../ShadersWGSL/glowMapMerge.fragment\"),\r\n                import(\"../ShadersWGSL/glowMapMerge.vertex\"),\r\n                import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/glowMapMerge.fragment\"), import(\"../Shaders/glowMapMerge.vertex\"), import(\"../Shaders/glowBlurPostProcess.fragment\")]);\r\n        }\r\n\r\n        await super._importShadersAsync();\r\n    }\r\n\r\n    public override getEffectName(): string {\r\n        return ThinHighlightLayer.EffectName;\r\n    }\r\n\r\n    public override _numInternalDraws(): number {\r\n        return 2; // we need two rendering, one for the inner glow and the other for the outer glow\r\n    }\r\n\r\n    public override _createMergeEffect(): Effect {\r\n        return this._engine.createEffect(\r\n            \"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\"],\r\n            this._options.isStroke ? \"#define STROKE \\n\" : undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this._shaderLanguage,\r\n            this._shadersLoaded\r\n                ? undefined\r\n                : async () => {\r\n                      await this._importShadersAsync();\r\n                      this._shadersLoaded = true;\r\n                  }\r\n        );\r\n    }\r\n\r\n    public override _createTextureAndPostProcesses(): void {\r\n        if (this._options.alphaBlendingMode === Constants.ALPHA_COMBINE) {\r\n            this._downSamplePostprocess = new ThinPassPostProcess(\"HighlightLayerPPP\", this._scene.getEngine());\r\n            this._horizontalBlurPostprocess = new ThinGlowBlurPostProcess(\"HighlightLayerHBP\", this._scene.getEngine(), new Vector2(1.0, 0), this._options.blurHorizontalSize);\r\n            this._verticalBlurPostprocess = new ThinGlowBlurPostProcess(\"HighlightLayerVBP\", this._scene.getEngine(), new Vector2(0, 1.0), this._options.blurVerticalSize);\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        } else {\r\n            this._horizontalBlurPostprocess = new ThinBlurPostProcess(\"HighlightLayerHBP\", this._scene.getEngine(), new Vector2(1.0, 0), this._options.blurHorizontalSize / 2);\r\n            this._verticalBlurPostprocess = new ThinBlurPostProcess(\"HighlightLayerVBP\", this._scene.getEngine(), new Vector2(0, 1.0), this._options.blurVerticalSize / 2);\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n    }\r\n\r\n    public override needStencil(): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh || !this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture: Nullable<any> = null;\r\n        const highlightLayerMesh = this._meshes[mesh.uniqueId];\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            emissiveTexture = (<any>material).emissiveTexture;\r\n        }\r\n        return super._isSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    public override _canRenderMesh(_mesh: AbstractMesh, _material: Material): boolean {\r\n        // all meshes can be rendered in the highlight layer, even transparent ones\r\n        return true;\r\n    }\r\n\r\n    public override _internalCompose(effect: Effect, renderIndex: number): void {\r\n        // Texture\r\n        this.bindTexturesForCompose(effect);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        engine.cacheStencilState();\r\n\r\n        // Stencil operations\r\n        engine.setStencilOperationPass(Constants.REPLACE);\r\n        engine.setStencilOperationFail(Constants.KEEP);\r\n        engine.setStencilOperationDepthFail(Constants.KEEP);\r\n\r\n        // Draw order\r\n        engine.setStencilMask(0x00);\r\n        engine.setStencilBuffer(true);\r\n        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n\r\n        // 2 passes inner outer\r\n        if (this.outerGlow && renderIndex === 0) {\r\n            // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\r\n            effect.setFloat(\"offset\", 0);\r\n            engine.setStencilFunction(Constants.NOTEQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n        if (this.innerGlow && renderIndex === 1) {\r\n            // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\r\n            effect.setFloat(\"offset\", 1);\r\n            engine.setStencilFunction(Constants.EQUAL);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Restore Cache\r\n        engine.restoreStencilState();\r\n    }\r\n\r\n    public override _setEmissiveTextureAndColor(mesh: Mesh, _subMesh: SubMesh, material: Material): void {\r\n        const highlightLayerMesh = this._meshes![mesh.uniqueId];\r\n        if (highlightLayerMesh) {\r\n            this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n        }\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n            this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this._emissiveTextureAndColor.texture = null;\r\n        }\r\n    }\r\n\r\n    public override shouldRender(): boolean {\r\n        return this._meshes && super.shouldRender() ? true : false;\r\n    }\r\n\r\n    public override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n            return false;\r\n        }\r\n\r\n        return super.hasMesh(mesh);\r\n    }\r\n\r\n    public override _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define HIGHLIGHT\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (!meshExcluded) {\r\n            const obj: IHighlightLayerExcludedMesh = {\r\n                mesh: mesh,\r\n                beforeBind: null,\r\n                afterRender: null,\r\n                stencilState: false,\r\n            };\r\n\r\n            obj.beforeBind = mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                    return;\r\n                }\r\n                obj.stencilState = mesh.getEngine().getStencilBuffer();\r\n                mesh.getEngine().setStencilBuffer(false);\r\n            });\r\n\r\n            obj.afterRender = mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                    return;\r\n                }\r\n                mesh.getEngine().setStencilBuffer(obj.stencilState);\r\n            });\r\n\r\n            this._excludedMeshes[mesh.uniqueId] = obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        const meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (meshExcluded) {\r\n            if (meshExcluded.beforeBind) {\r\n                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\r\n            }\r\n\r\n            if (meshExcluded.afterRender) {\r\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\r\n            }\r\n        }\r\n\r\n        this._excludedMeshes[mesh.uniqueId] = null;\r\n    }\r\n\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!this._meshes || !super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return !!this._meshes[mesh.uniqueId];\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            meshHighlight.color = color;\r\n        } else {\r\n            this._meshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                color: color,\r\n                // Lambda required for capture due to Observable this context\r\n                observerHighlight: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                        return;\r\n                    }\r\n                    if (this.isEnabled) {\r\n                        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n                            this._defaultStencilReference(mesh);\r\n                        } else {\r\n                            mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n                        }\r\n                    }\r\n                }),\r\n                observerDefault: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    if (this._mainObjectRendererRenderPassId !== -1 && this._mainObjectRendererRenderPassId !== this._engine.currentRenderPassId) {\r\n                        return;\r\n                    }\r\n                    if (this.isEnabled) {\r\n                        this._defaultStencilReference(mesh);\r\n                    }\r\n                }),\r\n                glowEmissiveOnly: glowEmissiveOnly,\r\n            };\r\n\r\n            mesh.onDisposeObservable.add(() => {\r\n                this._disposeMesh(mesh);\r\n            });\r\n        }\r\n\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        const meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            if (meshHighlight.observerHighlight) {\r\n                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n            }\r\n\r\n            if (meshHighlight.observerDefault) {\r\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n            }\r\n            delete this._meshes[mesh.uniqueId];\r\n        }\r\n\r\n        this._shouldRender = false;\r\n        for (const meshHighlightToCheck in this._meshes) {\r\n            if (this._meshes[meshHighlightToCheck]) {\r\n                this._shouldRender = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const uniqueId in this._meshes) {\r\n            if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\r\n                const mesh = this._meshes[uniqueId];\r\n                if (mesh) {\r\n                    this.removeMesh(mesh.mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _defaultStencilReference(mesh: Mesh) {\r\n        mesh.getScene().getEngine().setStencilFunctionReference(ThinHighlightLayer.NormalMeshStencilReference);\r\n    }\r\n\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    public override dispose(): void {\r\n        if (this._meshes) {\r\n            // Clean mesh references\r\n            for (const id in this._meshes) {\r\n                const meshHighlight = this._meshes[id];\r\n                if (meshHighlight && meshHighlight.mesh) {\r\n                    if (meshHighlight.observerHighlight) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n                    }\r\n\r\n                    if (meshHighlight.observerDefault) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n                    }\r\n                }\r\n            }\r\n            this._meshes = null;\r\n        }\r\n\r\n        if (this._excludedMeshes) {\r\n            for (const id in this._excludedMeshes) {\r\n                const meshHighlight = this._excludedMeshes[id];\r\n                if (meshHighlight) {\r\n                    if (meshHighlight.beforeBind) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\r\n                    }\r\n\r\n                    if (meshHighlight.afterRender) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\r\n                    }\r\n                }\r\n            }\r\n            this._excludedMeshes = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcessOptions } from \"../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\n\r\nimport type { ThinPassPostProcess } from \"core/PostProcesses/thinPassPostProcess\";\r\nimport type { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\nimport type { IThinHighlightLayerOptions } from \"./thinHighlightLayer\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport { ThinHighlightLayer } from \"./thinHighlightLayer\";\r\nimport { ThinGlowBlurPostProcess } from \"./thinEffectLayer\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @returns The highlight layer if found otherwise null.\r\n         */\r\n        getHighlightLayerByName(name: string): Nullable<HighlightLayer>;\r\n    }\r\n}\r\n\r\nScene.prototype.getHighlightLayerByName = function (name: string): Nullable<HighlightLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as HighlightLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\ninterface IBlurPostProcess extends PostProcess {\r\n    kernel: number;\r\n}\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\r\nclass GlowBlurPostProcess extends PostProcess {\r\n    protected override _effectWrapper: ThinGlowBlurPostProcess;\r\n\r\n    constructor(\r\n        name: string,\r\n        public direction: Vector2,\r\n        public kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinGlowBlurPostProcess.Uniforms,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinGlowBlurPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinGlowBlurPostProcess(name, engine, direction, kernel, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.onApplyObservable.add(() => {\r\n            this._effectWrapper.textureWidth = this.width;\r\n            this._effectWrapper.textureHeight = this.height;\r\n        });\r\n    }\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/glowBlurPostProcess.fragment\"));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IHighlightLayerOptions extends IThinHighlightLayerOptions {}\r\n\r\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\r\nexport class HighlightLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static get NeutralColor() {\r\n        return ThinHighlightLayer.NeutralColor;\r\n    }\r\n\r\n    public static set NeutralColor(value: Color4) {\r\n        ThinHighlightLayer.NeutralColor = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public get innerGlow() {\r\n        return this._thinEffectLayer.innerGlow;\r\n    }\r\n\r\n    public set innerGlow(value: boolean) {\r\n        this._thinEffectLayer.innerGlow = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public get outerGlow() {\r\n        return this._thinEffectLayer.outerGlow;\r\n    }\r\n\r\n    public set outerGlow(value: boolean) {\r\n        this._thinEffectLayer.outerGlow = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._thinEffectLayer.blurHorizontalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._thinEffectLayer.blurVerticalSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurHorizontalSize(): number {\r\n        return this._thinEffectLayer.blurHorizontalSize;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurVerticalSize(): number {\r\n        return this._thinEffectLayer.blurVerticalSize;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    @serialize(\"options\")\r\n    private _options: Required<IHighlightLayerOptions>;\r\n\r\n    protected override readonly _thinEffectLayer: ThinHighlightLayer;\r\n    private _downSamplePostprocess: PassPostProcess;\r\n    private _horizontalBlurPostprocess: IBlurPostProcess;\r\n    private _verticalBlurPostprocess: IBlurPostProcess;\r\n    private _blurTexture: RenderTargetTexture;\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IHighlightLayerOptions>) {\r\n        super(name, scene, options !== undefined ? !!options.forceGLSL : false, new ThinHighlightLayer(name, scene, options));\r\n\r\n        // Warn on stencil\r\n        if (!this._engine.isStencilEnable) {\r\n            Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\r\n        }\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            forceGLSL: false,\r\n            isStroke: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return HighlightLayer.EffectName;\r\n    }\r\n\r\n    protected override _numInternalDraws(): number {\r\n        return 2; // we need two rendering, one for the inner glow and the other for the outer glow\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect created\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        return this._thinEffectLayer._createMergeEffect();\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the highlight layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\r\n        blurTextureWidth = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        this._blurTexture = new RenderTargetTexture(\r\n            \"HighlightLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.anisotropicFilteringLevel = 16;\r\n        this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\r\n        this._blurTexture.renderParticles = false;\r\n        this._blurTexture.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture];\r\n\r\n        this._thinEffectLayer.bindTexturesForCompose = (effect: Effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture);\r\n        };\r\n\r\n        this._thinEffectLayer._createTextureAndPostProcesses();\r\n\r\n        if (this._options.alphaBlendingMode === Constants.ALPHA_COMBINE) {\r\n            this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", {\r\n                size: this._options.blurTextureSizeRatio,\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine: this._scene.getEngine(),\r\n                effectWrapper: this._thinEffectLayer._postProcesses[0] as ThinPassPostProcess,\r\n            });\r\n            this._downSamplePostprocess.externalTextureSamplerBinding = true;\r\n            this._downSamplePostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, {\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine: this._scene.getEngine(),\r\n                effectWrapper: this._thinEffectLayer._postProcesses[1] as ThinGlowBlurPostProcess,\r\n            });\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, {\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine: this._scene.getEngine(),\r\n                effectWrapper: this._thinEffectLayer._postProcesses[2] as ThinGlowBlurPostProcess,\r\n            });\r\n            this._verticalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        } else {\r\n            this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\r\n                size: {\r\n                    width: blurTextureWidth,\r\n                    height: blurTextureHeight,\r\n                },\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine: this._scene.getEngine(),\r\n                textureType,\r\n                effectWrapper: this._thinEffectLayer._postProcesses[0] as ThinBlurPostProcess,\r\n            });\r\n            this._horizontalBlurPostprocess.width = blurTextureWidth;\r\n            this._horizontalBlurPostprocess.height = blurTextureHeight;\r\n            this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\r\n                size: {\r\n                    width: blurTextureWidth,\r\n                    height: blurTextureHeight,\r\n                },\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine: this._scene.getEngine(),\r\n                textureType,\r\n            });\r\n\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this.onBeforeBlurObservable.notifyObservers(this);\r\n\r\n            const internalTexture = this._blurTexture.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses, internalTexture, true);\r\n                this._engine.unBindFramebuffer(internalTexture, true);\r\n            }\r\n\r\n            this.onAfterBlurObservable.notifyObservers(this);\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return this._thinEffectLayer.needStencil();\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        return this._thinEffectLayer.isReady(subMesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderIndex\r\n     */\r\n    protected _internalRender(effect: Effect, renderIndex: number): void {\r\n        this._thinEffectLayer._internalCompose(effect, renderIndex);\r\n    }\r\n\r\n    /**\r\n     * @returns true if the layer contains information to display, otherwise false.\r\n     */\r\n    public override shouldRender(): boolean {\r\n        return this._thinEffectLayer.shouldRender();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this._thinEffectLayer._shouldRenderMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected override _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._thinEffectLayer._canRenderMesh(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected override _addCustomEffectDefines(defines: string[]): void {\r\n        this._thinEffectLayer._addCustomEffectDefines(defines);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        this._thinEffectLayer._setEmissiveTextureAndColor(mesh, subMesh, material);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        this._thinEffectLayer.addExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        this._thinEffectLayer.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n     */\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._thinEffectLayer.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        this._thinEffectLayer.addMesh(mesh, color, glowEmissiveOnly);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        this._thinEffectLayer.removeMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        this._thinEffectLayer.removeAllMeshes();\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer._disposeMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public override getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this Highlight layer\r\n     * @returns a serialized Highlight layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.HighlightLayer\";\r\n\r\n        // Highlighted meshes\r\n        serializationObject.meshes = [];\r\n\r\n        const meshes = this._thinEffectLayer._meshes;\r\n        if (meshes) {\r\n            for (const m in meshes) {\r\n                const mesh = meshes[m];\r\n\r\n                if (mesh) {\r\n                    serializationObject.meshes.push({\r\n                        glowEmissiveOnly: mesh.glowEmissiveOnly,\r\n                        color: mesh.color.asArray(),\r\n                        meshId: mesh.mesh.id,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        const excludedMeshes = this._thinEffectLayer._excludedMeshes;\r\n        if (excludedMeshes) {\r\n            for (const e in excludedMeshes) {\r\n                const excludedMesh = excludedMeshes[e];\r\n\r\n                if (excludedMesh) {\r\n                    serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Highlight layer from parsed Highlight layer data\r\n     * @param parsedHightlightLayer defines the Highlight layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the Highlight layer information\r\n     * @returns a parsed Highlight layer\r\n     */\r\n    public static override Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer {\r\n        const hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                hl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\r\n            const highlightedMesh = parsedHightlightLayer.meshes[index];\r\n            const mesh = scene.getMeshById(highlightedMesh.meshId);\r\n\r\n            if (mesh) {\r\n                hl.addMesh(<Mesh>mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\r\n            }\r\n        }\r\n\r\n        return hl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.HighlightLayer\", HighlightLayer);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASM,IAAO,sBAAP,MAAO,6BAA4B,cAAa;EAqB/B,eAAe,WAAoB,MAAoB;AACtE,QAAI,WAAW;AACX,WAAK,eAAe;AACpB,WAAK,KAAK,QAAQ,IAAI,CAAC,OAAO,mCAAuC,GAAA,OAAO,iCAAuC,CAAA,CAAA,CAAA;IACvH,OAAO;AACH,WAAK,KAAK,QAAQ,IAAI,CAAC,OAAO,mCAAmC,GAAA,OAAO,iCAAmC,CAAA,CAAA,CAAA;IAC/G;EACJ;;;;;;;;;EAeA,YAAY,MAAc,SAAmC,MAAM,WAAqB,QAAiB,SAAsC;AAC3I,UAAM,wBAAwB,CAAC,EAAC,mCAAS;AACzC,UAAM;MACF,GAAG;MACH;MACA,QAAQ,UAAU,OAAO;MACzB,gBAAgB;MAChB,kBAAkB;MAClB,gBAAgB,qBAAoB;MACpC,UAAU,qBAAoB;MAC9B,UAAU,qBAAoB;MAC9B,WAAW,qBAAoB;MAC/B,kBAAkB;KACrB;AAxBK,SAAA,eAAwB;AAC1B,SAAA,iBAAyB;AAsC1B,SAAA,eAAuB;AAKvB,SAAA,gBAAwB;AAlB3B,SAAK,QAAQ,mBAAmB;AAEhC,QAAI,cAAc,QAAW;AACzB,WAAK,YAAY;IACrB;AACA,QAAI,WAAW,QAAW;AACtB,WAAK,SAAS;IAClB;EACJ;;;;EAkBA,IAAW,OAAO,GAAS;AACvB,QAAI,KAAK,iBAAiB,GAAG;AACzB;IACJ;AAEA,QAAI,KAAK,IAAI,GAAG,CAAC;AACjB,SAAK,eAAe;AACpB,SAAK,UAAU,KAAK,mBAAmB,CAAC;AACxC,QAAI,CAAC,KAAK,QAAQ,kBAAkB;AAChC,WAAK,kBAAiB;IAC1B;EACJ;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK;EAChB;;;;EAKA,IAAW,YAAY,GAAU;AAC7B,QAAI,KAAK,iBAAiB,GAAG;AACzB;IACJ;AACA,SAAK,eAAe;AACpB,QAAI,CAAC,KAAK,QAAQ,kBAAkB;AAChC,WAAK,kBAAiB;IAC1B;EACJ;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK;EAChB;EAEgB,OAAI;AAChB,UAAM,KAAI;AACV,SAAK,aAAa,OAAQ,UAAU,SAAU,IAAI,KAAK,eAAgB,KAAK,UAAU,GAAI,IAAI,KAAK,gBAAiB,KAAK,UAAU,CAAC;EACxI;;EAGO,kBAAkB,YAAuC,SAAkD;AAE9G,UAAM,IAAI,KAAK;AACf,UAAM,eAAe,IAAI,KAAK;AAG9B,QAAI,UAAU,CAAA;AACd,QAAI,UAAU,CAAA;AACd,QAAI,cAAc;AAClB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,YAAM,IAAI,KAAK,IAAI;AACnB,YAAM,IAAI,KAAK,gBAAgB,IAAI,IAAM,CAAC;AAC1C,cAAQ,CAAC,IAAI,IAAI;AACjB,cAAQ,CAAC,IAAI;AACb,qBAAe;IACnB;AAGA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,cAAQ,CAAC,KAAK;IAClB;AAIA,UAAM,wBAAwB,CAAA;AAC9B,UAAM,wBAAwB,CAAA;AAE9B,UAAM,oBAAoB,CAAA;AAE1B,aAAS,IAAI,GAAG,KAAK,aAAa,KAAK,GAAG;AACtC,YAAM,IAAI,KAAK,IAAI,IAAI,GAAG,KAAK,MAAM,WAAW,CAAC;AAEjD,YAAM,qBAAqB,MAAM;AAEjC,UAAI,oBAAoB;AACpB,0BAAkB,KAAK,EAAE,GAAG,QAAQ,CAAC,GAAG,GAAG,QAAQ,CAAC,EAAC,CAAE;MAC3D,OAAO;AACH,cAAM,aAAa,MAAM;AAEzB,cAAM,eAAe,QAAQ,CAAC,IAAI,QAAQ,CAAC,KAAK,aAAa,MAAM;AACnE,cAAM,eAAe,QAAQ,CAAC,IAAI,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC;AAEjE,YAAI,iBAAiB,GAAG;AACpB,4BAAkB,KAAK,EAAE,GAAG,QAAQ,CAAC,GAAG,GAAG,QAAQ,CAAC,EAAC,CAAE;AACvD,4BAAkB,KAAK,EAAE,GAAG,QAAQ,IAAI,CAAC,GAAG,GAAG,QAAQ,IAAI,CAAC,EAAC,CAAE;QACnE,OAAO;AACH,4BAAkB,KAAK,EAAE,GAAG,cAAc,GAAG,aAAY,CAAE;AAC3D,4BAAkB,KAAK,EAAE,GAAG,CAAC,cAAc,GAAG,aAAY,CAAE;QAChE;MACJ;IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AAC/C,4BAAsB,CAAC,IAAI,kBAAkB,CAAC,EAAE;AAChD,4BAAsB,CAAC,IAAI,kBAAkB,CAAC,EAAE;IACpD;AAGA,cAAU;AACV,cAAU;AAGV,UAAM,iBAAiB,KAAK,QAAQ,OAAO,QAAO,EAAG,qBAAqB,KAAK,QAAQ,mBAAc,IAA2B,IAAI;AACpI,UAAM,kBAAkB,KAAK,IAAI,gBAAgB,CAAC,IAAI;AAEtD,QAAI,eAAe,KAAK,IAAI,QAAQ,QAAQ,eAAe;AAE3D,QAAI,UAAU;AACd,eAAW,KAAK;AAGhB,QAAI,KAAK,eAAe,QAAQ,KAAK,KAAK,IAAI;AAC1C,iBAAW,yBAAyB,KAAK,WAAW,QAAQ,eAAe,CAAC,CAAC,CAAC;;AAC9E;IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACnC,iBAAW,wBAAwB,CAAC,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;AACnE,iBAAW,wBAAwB,CAAC,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;IACvE;AAEA,QAAI,WAAW;AACf,aAAS,IAAI,iBAAiB,IAAI,QAAQ,QAAQ,KAAK;AACnD,iBAAW,4BAA4B,QAAQ,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;AAC9E,iBAAW,4BAA4B,QAAQ,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;AAC9E;IACJ;AAEA,QAAI,KAAK,aAAa;AAClB,iBAAW;IACf;AAEA,SAAK,QAAQ,mBAAmB;AAEhC,SAAK,aACD,SACA,MACA,MACA;MACI;MACA;OAEJ,YACA,OAAO;EAEf;;;;;;;;;;EAWU,mBAAmB,aAAmB;AAC5C,UAAM,IAAI,KAAK,MAAM,WAAW;AAChC,eAAW,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,GAAG;AAC7C,UAAI,IAAI,MAAM,KAAK,KAAK,MAAM,IAAI,CAAC,IAAI,MAAM,KAAK,IAAI,GAAG;AACrD,eAAO,KAAK,IAAI,GAAG,CAAC;MACxB;IACJ;AACA,WAAO,KAAK,IAAI,GAAG,CAAC;EACxB;;;;;;EAOU,gBAAgB,GAAS;AAQ/B,UAAM,QAAQ,IAAI;AAClB,UAAM,cAAc,KAAK,KAAK,IAAM,KAAK,EAAE,IAAI;AAC/C,UAAM,WAAW,EAAG,IAAI,KAAM,IAAM,QAAQ;AAC5C,UAAM,SAAU,IAAM,cAAe,KAAK,IAAI,QAAQ;AACtD,WAAO;EACX;;;;;;;EAQU,WAAW,GAAW,iBAAiB,GAAC;AAC9C,WAAO,EAAE,QAAQ,cAAc,EAAE,QAAQ,OAAO,EAAE;EACtD;;AAxRuB,oBAAA,YAAY;AAKZ,oBAAA,cAAc;AAKd,oBAAA,WAAW,CAAC,SAAS,WAAW;AAKhC,oBAAA,WAAW,CAAC,0BAA0B;;;ACR3D,IAAO,kBAAP,MAAO,yBAAwB,YAAW;;EAG5C,IAAW,YAAS;AAChB,WAAO,KAAK,eAAe;EAC/B;EAEA,IAAW,UAAU,OAAc;AAC/B,SAAK,eAAe,YAAY;EACpC;;;;EAMA,IAAW,OAAO,GAAS;AACvB,SAAK,eAAe,SAAS;EACjC;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,eAAe;EAC/B;;;;EAMA,IAAW,YAAY,GAAU;AAC7B,SAAK,eAAe,cAAc;EACtC;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,eAAe;EAC/B;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;;;;;;;;;;;;;EAmBA,YACI,MACA,WACA,QACA,SACA,SAA2B,MAC3B,eAAuB,QAAQ,uBAC/B,QACA,UACA,cAAc,GAAA,UAAU,IAAA,mBAAyB,OACjD,gBACA,GAAA;AAGA,UAAM,wBAAwB,OAAO,YAAY,WAAW,mBAAmB,CAAC,CAAC,QAAQ;AACzF,UAAM,eAAe;MACjB,UAAU,oBAAoB;MAC9B,UAAU,oBAAoB;MAC9B,MAAM,OAAO,YAAY,WAAW,UAAU;MAC9C;MACA;MACA;MACA;MACA;MACA,WAAW,oBAAoB;MAC/B,iBAAiB,EAAE,cAAc,GAAG,UAAU,EAAC;MAC/C;MACA;MACA,GAAI;MACJ,kBAAkB;;AAGtB,UAAM,MAAM,oBAAoB,aAAa;MACzC,eAAe,OAAO,YAAY,YAAY,CAAC,QAAQ,gBAAgB,IAAI,oBAAoB,MAAM,QAAQ,QAAW,QAAW,YAAY,IAAI;MACnJ,GAAG;KACN;AAED,SAAK,eAAe,QAAQ,mBAAmB;AAE/C,SAAK,YAAY;AACjB,SAAK,kBAAkB,IAAI,MAAK;AAC5B,WAAK,eAAe,eAAe,KAAK,iBAAiB,KAAK,eAAe,QAAQ,KAAK;AAC1F,WAAK,eAAe,gBAAgB,KAAK,iBAAiB,KAAK,eAAe,SAAS,KAAK;IAChG,CAAC;AAED,SAAK,SAAS;EAClB;EAEgB,aACZ,WAA6B,MAC7B,YAAgC,MAChC,YAAgC,MAChC,kBACA,YACA,SAAkD;AAElD,SAAK,eAAe,kBAAkB,YAAY,OAAO;EAC7D;;;;EAKO,OAAgB,OAAO,mBAAwB,cAAsB,OAAc,SAAe;AACrG,WAAO,oBAAoB,MACvB,MAAK;AACD,aAAO,IAAI,iBACP,kBAAkB,MAClB,kBAAkB,WAClB,kBAAkB,QAClB,kBAAkB,SAClB,cACA,kBAAkB,0BAClB,MAAM,UAAS,GACf,kBAAkB,UAClB,kBAAkB,aAClB,QACA,KAAK;IAEb,GACA,mBACA,OACA,OAAO;EAEf;;AAlJA,WAAA;EADC,mBAAkB;;AAanB,WAAA;EADC,UAAS;;AAgBV,WAAA;EADC,UAAS;;AA2Hd,cAAc,2BAA2B,eAAe;;;AC7DlD,IAAO,qBAAP,MAAO,4BAA2B,gBAAe;;;;EAmCnD,IAAW,mBAAmB,OAAa;AACvC,SAAK,2BAA2B,SAAS;AACzC,SAAK,SAAS,qBAAqB;EACvC;;;;EAKA,IAAW,iBAAiB,OAAa;AACrC,SAAK,yBAAyB,SAAS;AACvC,SAAK,SAAS,mBAAmB;EACrC;;;;EAKA,IAAW,qBAAkB;AACzB,WAAO,KAAK,2BAA2B;EAC3C;;;;EAKA,IAAW,mBAAgB;AACvB,WAAO,KAAK,yBAAyB;EACzC;;;;;;;;EA0BA,YAAY,MAAc,OAAe,SAA+C,mBAAmB,OAAK;AAC5G,UAAM,MAAM,OAAO,YAAY,SAAY,CAAC,CAAC,QAAQ,YAAY,KAAK;AA9DnE,SAAA,YAAqB;AAKrB,SAAA,YAAqB;AAgCpB,SAAA,uCAAuC,oBAAmB;AAU3D,SAAA,UAAqE,CAAA;AAErE,SAAA,kBAAqF,CAAA;AAGrF,SAAA,kCAAkC;AAYrC,SAAK,eAAe,oBAAmB;AAGvC,SAAK,WAAW;MACZ,kBAAkB;MAClB,sBAAsB;MACtB,sBAAsB;MACtB,oBAAoB;MACpB,kBAAkB;MAClB,mBAAmB;MACnB,QAAQ;MACR,kBAAkB;MAClB,WAAW;MACX,iBAAiB;MACjB,UAAU;MACV,GAAG;;AAIP,SAAK,MAAM,KAAK,QAAQ;AAGxB,SAAK,gBAAgB;AAErB,QAAI,kBAAkB;AAElB,WAAK,+BAA8B;IACvC;EACJ;;;;;EAMO,eAAY;AACf,WAAO;EACX;EAEmB,MAAM,sBAAmB;AACxC,QAAI,KAAK,oBAAe,GAA0B;AAC9C,YAAM,QAAQ,IAAI;QACd,OAAO,qCAAuC;QAC9C,OAAO,mCAAqC;QAC5C,OAAO,4CAA8C;OACxD;IACL,OAAO;AACH,YAAM,QAAQ,IAAI,CAAC,OAAO,qCAAqC,GAAA,OAAO,mCAAmC,GAAM,OAAC,4CAA6C,CAAA,CAAA;IACjK;AAEA,UAAM,MAAM,oBAAmB;EACnC;EAEgB,gBAAa;AACzB,WAAO,oBAAmB;EAC9B;EAEgB,oBAAiB;AAC7B,WAAO;EACX;EAEgB,qBAAkB;AAC9B,WAAO,KAAK,QAAQ,aAChB,gBACA,CAAC,aAAa,YAAY,GAC1B,CAAC,QAAQ,GACT,CAAC,gBAAgB,GACjB,KAAK,SAAS,WAAW,sBAAsB,QAC/C,QACA,QACA,QACA,QACA,KAAK,iBACL,KAAK,iBACC,SACA,YAAW;AACP,YAAM,KAAK,oBAAmB;AAC9B,WAAK,iBAAiB;IAC1B,CAAC;EAEf;EAEgB,iCAA8B;AAC1C,QAAI,KAAK,SAAS,sBAAsB,GAAA;AACpC,WAAK,yBAAyB,IAAI,oBAAoB,qBAAqB,KAAK,OAAO,UAAS,CAAE;AAClG,WAAK,6BAA6B,IAAI,wBAAwB,qBAAqB,KAAK,OAAO,UAAS,GAAI,IAAI,QAAQ,GAAK,CAAC,GAAG,KAAK,SAAS,kBAAkB;AACjK,WAAK,2BAA2B,IAAI,wBAAwB,qBAAqB,KAAK,OAAO,UAAS,GAAI,IAAI,QAAQ,GAAG,CAAG,GAAG,KAAK,SAAS,gBAAgB;AAC7J,WAAK,iBAAiB,CAAC,KAAK,wBAAwB,KAAK,4BAA4B,KAAK,wBAAwB;IACtH,OAAO;AACH,WAAK,6BAA6B,IAAI,oBAAoB,qBAAqB,KAAK,OAAO,UAAS,GAAI,IAAI,QAAQ,GAAK,CAAC,GAAG,KAAK,SAAS,qBAAqB,CAAC;AACjK,WAAK,2BAA2B,IAAI,oBAAoB,qBAAqB,KAAK,OAAO,UAAS,GAAI,IAAI,QAAQ,GAAG,CAAG,GAAG,KAAK,SAAS,mBAAmB,CAAC;AAC7J,WAAK,iBAAiB,CAAC,KAAK,4BAA4B,KAAK,wBAAwB;IACzF;EACJ;EAEgB,cAAW;AACvB,WAAO;EACX;EAEgB,QAAQ,SAAkB,cAAqB;AAC3D,UAAM,WAAW,QAAQ,YAAW;AACpC,UAAM,OAAO,QAAQ,iBAAgB;AAErC,QAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,SAAS;AACrC,aAAO;IACX;AAEA,QAAI,kBAAiC;AACrC,UAAM,qBAAqB,KAAK,QAAQ,KAAK,QAAQ;AAErD,QAAI,sBAAsB,mBAAmB,oBAAoB,UAAU;AACvE,wBAAwB,SAAU;IACtC;AACA,WAAO,MAAM,gBAAgB,SAAS,cAAc,eAAe;EACvE;EAEgB,eAAe,OAAqB,WAAmB;AAEnE,WAAO;EACX;EAEgB,iBAAiB,QAAgB,aAAmB;AAEhE,SAAK,uBAAuB,MAAM;AAGlC,UAAM,SAAS,KAAK;AACpB,WAAO,kBAAiB;AAGxB,WAAO,wBAAwB,IAAA;AAC/B,WAAO,wBAAwB,IAAA;AAC/B,WAAO,6BAA6B,IAAA;AAGpC,WAAO,eAAe,CAAI;AAC1B,WAAO,iBAAiB,IAAI;AAC5B,WAAO,4BAA4B,KAAK,oCAAoC;AAG5E,QAAI,KAAK,aAAa,gBAAgB,GAAG;AAErC,aAAO,SAAS,UAAU,CAAC;AAC3B,aAAO,mBAAmB,GAAA;AAC1B,aAAO,iBAAiB,SAAS,kBAAkB,GAAG,CAAC;IAC3D;AACA,QAAI,KAAK,aAAa,gBAAgB,GAAG;AAErC,aAAO,SAAS,UAAU,CAAC;AAC3B,aAAO,mBAAmB,GAAA;AAC1B,aAAO,iBAAiB,SAAS,kBAAkB,GAAG,CAAC;IAC3D;AAGA,WAAO,oBAAmB;EAC9B;EAEgB,4BAA4B,MAAY,UAAmB,UAAkB;AACzF,UAAM,qBAAqB,KAAK,QAAS,KAAK,QAAQ;AACtD,QAAI,oBAAoB;AACpB,WAAK,yBAAyB,MAAM,IAAI,mBAAmB,MAAM,GAAG,mBAAmB,MAAM,GAAG,mBAAmB,MAAM,GAAG,CAAG;IACnI,OAAO;AACH,WAAK,yBAAyB,MAAM,IAAI,KAAK,aAAa,GAAG,KAAK,aAAa,GAAG,KAAK,aAAa,GAAG,KAAK,aAAa,CAAC;IAC9H;AAEA,QAAI,sBAAsB,mBAAmB,oBAAoB,UAAU;AACvE,WAAK,yBAAyB,UAAgB,SAAU;AACxD,WAAK,yBAAyB,MAAM,IAAI,GAAK,GAAK,GAAK,CAAG;IAC9D,OAAO;AACH,WAAK,yBAAyB,UAAU;IAC5C;EACJ;EAEgB,eAAY;AACxB,WAAO,KAAK,WAAW,MAAM,aAAY,IAAK,OAAO;EACzD;EAEgB,kBAAkB,MAAU;AACxC,QAAI,KAAK,mBAAmB,KAAK,gBAAgB,KAAK,QAAQ,GAAG;AAC7D,aAAO;IACX;AAEA,WAAO,MAAM,QAAQ,IAAI;EAC7B;EAEgB,wBAAwB,SAAiB;AACrD,YAAQ,KAAK,mBAAmB;EACpC;;;;;EAMO,gBAAgB,MAAU;AAC7B,QAAI,CAAC,KAAK,iBAAiB;AACvB;IACJ;AAEA,UAAM,eAAe,KAAK,gBAAgB,KAAK,QAAQ;AACvD,QAAI,CAAC,cAAc;AACf,YAAM,MAAmC;QACrC;QACA,YAAY;QACZ,aAAa;QACb,cAAc;;AAGlB,UAAI,aAAa,KAAK,uBAAuB,IAAI,CAACA,UAAc;AAC5D,YAAI,KAAK,oCAAoC,MAAM,KAAK,oCAAoC,KAAK,QAAQ,qBAAqB;AAC1H;QACJ;AACA,YAAI,eAAeA,MAAK,UAAS,EAAG,iBAAgB;AACpD,QAAAA,MAAK,UAAS,EAAG,iBAAiB,KAAK;MAC3C,CAAC;AAED,UAAI,cAAc,KAAK,wBAAwB,IAAI,CAACA,UAAc;AAC9D,YAAI,KAAK,oCAAoC,MAAM,KAAK,oCAAoC,KAAK,QAAQ,qBAAqB;AAC1H;QACJ;AACA,QAAAA,MAAK,UAAS,EAAG,iBAAiB,IAAI,YAAY;MACtD,CAAC;AAED,WAAK,gBAAgB,KAAK,QAAQ,IAAI;IAC1C;EACJ;;;;;EAMO,mBAAmB,MAAU;AAChC,QAAI,CAAC,KAAK,iBAAiB;AACvB;IACJ;AAEA,UAAM,eAAe,KAAK,gBAAgB,KAAK,QAAQ;AACvD,QAAI,cAAc;AACd,UAAI,aAAa,YAAY;AACzB,aAAK,uBAAuB,OAAO,aAAa,UAAU;MAC9D;AAEA,UAAI,aAAa,aAAa;AAC1B,aAAK,wBAAwB,OAAO,aAAa,WAAW;MAChE;IACJ;AAEA,SAAK,gBAAgB,KAAK,QAAQ,IAAI;EAC1C;EAEgB,QAAQ,MAAkB;AACtC,QAAI,CAAC,KAAK,WAAW,CAAC,MAAM,QAAQ,IAAI,GAAG;AACvC,aAAO;IACX;AAEA,WAAO,CAAC,CAAC,KAAK,QAAQ,KAAK,QAAQ;EACvC;;;;;;;EAQO,QAAQ,MAAY,OAAe,mBAAmB,OAAK;AAC9D,QAAI,CAAC,KAAK,SAAS;AACf;IACJ;AAEA,UAAM,gBAAgB,KAAK,QAAQ,KAAK,QAAQ;AAChD,QAAI,eAAe;AACf,oBAAc,QAAQ;IAC1B,OAAO;AACH,WAAK,QAAQ,KAAK,QAAQ,IAAI;QAC1B;QACA;;QAEA,mBAAmB,KAAK,uBAAuB,IAAI,CAACA,UAAc;AAC9D,cAAI,KAAK,oCAAoC,MAAM,KAAK,oCAAoC,KAAK,QAAQ,qBAAqB;AAC1H;UACJ;AACA,cAAI,KAAK,WAAW;AAChB,gBAAI,KAAK,mBAAmB,KAAK,gBAAgBA,MAAK,QAAQ,GAAG;AAC7D,mBAAK,yBAAyBA,KAAI;YACtC,OAAO;AACH,cAAAA,MAAK,SAAQ,EAAG,UAAS,EAAG,4BAA4B,KAAK,oCAAoC;YACrG;UACJ;QACJ,CAAC;QACD,iBAAiB,KAAK,wBAAwB,IAAI,CAACA,UAAc;AAC7D,cAAI,KAAK,oCAAoC,MAAM,KAAK,oCAAoC,KAAK,QAAQ,qBAAqB;AAC1H;UACJ;AACA,cAAI,KAAK,WAAW;AAChB,iBAAK,yBAAyBA,KAAI;UACtC;QACJ,CAAC;QACD;;AAGJ,WAAK,oBAAoB,IAAI,MAAK;AAC9B,aAAK,aAAa,IAAI;MAC1B,CAAC;IACL;AAEA,SAAK,gBAAgB;EACzB;;;;;EAMO,WAAW,MAAU;AACxB,QAAI,CAAC,KAAK,SAAS;AACf;IACJ;AAEA,UAAM,gBAAgB,KAAK,QAAQ,KAAK,QAAQ;AAChD,QAAI,eAAe;AACf,UAAI,cAAc,mBAAmB;AACjC,aAAK,uBAAuB,OAAO,cAAc,iBAAiB;MACtE;AAEA,UAAI,cAAc,iBAAiB;AAC/B,aAAK,wBAAwB,OAAO,cAAc,eAAe;MACrE;AACA,aAAO,KAAK,QAAQ,KAAK,QAAQ;IACrC;AAEA,SAAK,gBAAgB;AACrB,eAAW,wBAAwB,KAAK,SAAS;AAC7C,UAAI,KAAK,QAAQ,oBAAoB,GAAG;AACpC,aAAK,gBAAgB;AACrB;MACJ;IACJ;EACJ;;;;EAKO,kBAAe;AAClB,QAAI,CAAC,KAAK,SAAS;AACf;IACJ;AAEA,eAAW,YAAY,KAAK,SAAS;AACjC,UAAI,OAAO,UAAU,eAAe,KAAK,KAAK,SAAS,QAAQ,GAAG;AAC9D,cAAM,OAAO,KAAK,QAAQ,QAAQ;AAClC,YAAI,MAAM;AACN,eAAK,WAAW,KAAK,IAAI;QAC7B;MACJ;IACJ;EACJ;EAEQ,yBAAyB,MAAU;AACvC,SAAK,SAAQ,EAAG,UAAS,EAAG,4BAA4B,oBAAmB,0BAA0B;EACzG;EAEO,aAAa,MAAU;AAC1B,SAAK,WAAW,IAAI;AACpB,SAAK,mBAAmB,IAAI;EAChC;EAEgB,UAAO;AACnB,QAAI,KAAK,SAAS;AAEd,iBAAW,MAAM,KAAK,SAAS;AAC3B,cAAM,gBAAgB,KAAK,QAAQ,EAAE;AACrC,YAAI,iBAAiB,cAAc,MAAM;AACrC,cAAI,cAAc,mBAAmB;AACjC,0BAAc,KAAK,uBAAuB,OAAO,cAAc,iBAAiB;UACpF;AAEA,cAAI,cAAc,iBAAiB;AAC/B,0BAAc,KAAK,wBAAwB,OAAO,cAAc,eAAe;UACnF;QACJ;MACJ;AACA,WAAK,UAAU;IACnB;AAEA,QAAI,KAAK,iBAAiB;AACtB,iBAAW,MAAM,KAAK,iBAAiB;AACnC,cAAM,gBAAgB,KAAK,gBAAgB,EAAE;AAC7C,YAAI,eAAe;AACf,cAAI,cAAc,YAAY;AAC1B,0BAAc,KAAK,uBAAuB,OAAO,cAAc,UAAU;UAC7E;AAEA,cAAI,cAAc,aAAa;AAC3B,0BAAc,KAAK,wBAAwB,OAAO,cAAc,WAAW;UAC/E;QACJ;MACJ;AACA,WAAK,kBAAkB;IAC3B;AAEA,UAAM,QAAO;EACjB;;AAneuB,mBAAA,aAAa;AAMtB,mBAAA,eAAuB,IAAI,OAAO,GAAG,GAAG,GAAG,CAAC;AAK5C,mBAAA,8BAA8B;AAK9B,mBAAA,6BAA6B;;;ACtF/C,MAAM,UAAU,0BAA0B,SAAU,MAAY;;AAC5D,WAAS,QAAQ,GAAG,UAAQ,UAAK,iBAAL,mBAAmB,SAAQ,SAAS;AAC5D,QAAI,KAAK,aAAa,KAAK,EAAE,SAAS,QAAQ,KAAK,aAAa,KAAK,EAAE,cAAa,MAAO,eAAe,YAAY;AAClH,aAAa,KAAK,aAAa,KAAK;IACxC;EACJ;AAEA,SAAO;AACX;AAUA,IAAM,sBAAN,cAAkC,YAAW;EAGzC,YACI,MACO,WACA,QACP,SACA,SAA2B,MAC3B,eAAuB,QAAQ,uBAC/B,QACA,UAAkB;AAElB,UAAM,eAAe;MACjB,UAAU,wBAAwB;MAClC,MAAM,OAAO,YAAY,WAAW,UAAU;MAC9C;MACA;MACA;MACA;MACA,GAAI;;AAGR,UAAM,MAAM,wBAAwB,aAAa;MAC7C,eAAe,OAAO,YAAY,YAAY,CAAC,QAAQ,gBAAgB,IAAI,wBAAwB,MAAM,QAAQ,WAAW,QAAQ,YAAY,IAAI;MACpJ,GAAG;KACN;AArBM,SAAA,YAAA;AACA,SAAA,SAAA;AAsBP,SAAK,kBAAkB,IAAI,MAAK;AAC5B,WAAK,eAAe,eAAe,KAAK;AACxC,WAAK,eAAe,gBAAgB,KAAK;IAC7C,CAAC;EACL;EAEmB,eAAe,WAAoB,MAAoB;AACtE,QAAI,WAAW;AACX,WAAK,eAAe;AACpB,WAAK,KAAK,OAAO,4CAAgD,CAAA;IACrE,OAAO;AACH,WAAK,KAAK,OAAO,4CAA4C,CAAA;IACjE;AAEA,UAAM,eAAe,WAAW,IAAI;EACxC;;AAiBE,IAAO,iBAAP,MAAO,wBAAuB,YAAW;;;;;EAUpC,WAAW,eAAY;AAC1B,WAAO,mBAAmB;EAC9B;EAEO,WAAW,aAAa,OAAa;AACxC,uBAAmB,eAAe;EACtC;;;;EAMA,IAAW,YAAS;AAChB,WAAO,KAAK,iBAAiB;EACjC;EAEA,IAAW,UAAU,OAAc;AAC/B,SAAK,iBAAiB,YAAY;EACtC;;;;EAMA,IAAW,YAAS;AAChB,WAAO,KAAK,iBAAiB;EACjC;EAEA,IAAW,UAAU,OAAc;AAC/B,SAAK,iBAAiB,YAAY;EACtC;;;;EAKA,IAAW,mBAAmB,OAAa;AACvC,SAAK,iBAAiB,qBAAqB;EAC/C;;;;EAKA,IAAW,iBAAiB,OAAa;AACrC,SAAK,iBAAiB,mBAAmB;EAC7C;;;;EAMA,IAAW,qBAAkB;AACzB,WAAO,KAAK,iBAAiB;EACjC;;;;EAMA,IAAW,mBAAgB;AACvB,WAAO,KAAK,iBAAiB;EACjC;;;;;;;EA2BA,YAAY,MAAc,OAAe,SAAyC;AAC9E,UAAM,MAAM,OAAO,YAAY,SAAY,CAAC,CAAC,QAAQ,YAAY,OAAO,IAAI,mBAAmB,MAAM,OAAO,OAAO,CAAC;AAvBjH,SAAA,yBAAyB,IAAI,WAAU;AAKvC,SAAA,wBAAwB,IAAI,WAAU;AAqBzC,QAAI,CAAC,KAAK,QAAQ,iBAAiB;AAC/B,aAAO,KAAK,6IAA6I;IAC7J;AAGA,SAAK,WAAW;MACZ,kBAAkB;MAClB,sBAAsB;MACtB,sBAAsB;MACtB,oBAAoB;MACpB,kBAAkB;MAClB,mBAAmB;MACnB,QAAQ;MACR,kBAAkB;MAClB,iBAAiB;MACjB,WAAW;MACX,UAAU;MACV,GAAG;;AAIP,SAAK,MAAM,KAAK,QAAQ;AAGxB,SAAK,gBAAgB;EACzB;;;;;EAMO,gBAAa;AAChB,WAAO,gBAAe;EAC1B;EAEmB,oBAAiB;AAChC,WAAO;EACX;;;;;;EAOU,qBAAkB;AACxB,WAAO,KAAK,iBAAiB,mBAAkB;EACnD;;;;EAKU,iCAA8B;AACpC,QAAI,mBAAmB,KAAK,wBAAwB,QAAQ,KAAK,SAAS;AAC1E,QAAI,oBAAoB,KAAK,wBAAwB,SAAS,KAAK,SAAS;AAC5E,uBAAmB,KAAK,QAAQ,kBAAkB,iBAAiB,kBAAkB,KAAK,QAAQ,IAAI;AACtG,wBAAoB,KAAK,QAAQ,kBAAkB,iBAAiB,mBAAmB,KAAK,QAAQ,IAAI;AAExG,QAAI,cAAc;AAClB,QAAI,KAAK,QAAQ,QAAO,EAAG,wBAAwB;AAC/C,oBAAc;IAClB,OAAO;AACH,oBAAc;IAClB;AAEA,SAAK,eAAe,IAAI,oBACpB,yBACA;MACI,OAAO;MACP,QAAQ;OAEZ,KAAK,QACL,OACA,MACA,WAAW;AAEf,SAAK,aAAa,QAAQ,QAAQ;AAClC,SAAK,aAAa,QAAQ,QAAQ;AAClC,SAAK,aAAa,4BAA4B;AAC9C,SAAK,aAAa,mBAAmB,QAAQ,sBAAsB;AACnE,SAAK,aAAa,kBAAkB;AACpC,SAAK,aAAa,uBAAuB;AAEzC,SAAK,YAAY,CAAC,KAAK,YAAY;AAEnC,SAAK,iBAAiB,yBAAyB,CAAC,WAAkB;AAC9D,aAAO,WAAW,kBAAkB,KAAK,YAAY;IACzD;AAEA,SAAK,iBAAiB,+BAA8B;AAEpD,QAAI,KAAK,SAAS,sBAAsB,GAAA;AACpC,WAAK,yBAAyB,IAAI,gBAAgB,qBAAqB;QACnE,MAAM,KAAK,SAAS;QACpB,cAAc,QAAQ;QACtB,QAAQ,KAAK,OAAO,UAAS;QAC7B,eAAe,KAAK,iBAAiB,eAAe,CAAC;OACxD;AACD,WAAK,uBAAuB,gCAAgC;AAC5D,WAAK,uBAAuB,kBAAkB,IAAI,CAAC,WAAU;AACzD,eAAO,WAAW,kBAAkB,KAAK,YAAY;MACzD,CAAC;AAED,WAAK,6BAA6B,IAAI,oBAAoB,qBAAqB,IAAI,QAAQ,GAAK,CAAC,GAAG,KAAK,SAAS,oBAAoB;QAClI,cAAc,QAAQ;QACtB,QAAQ,KAAK,OAAO,UAAS;QAC7B,eAAe,KAAK,iBAAiB,eAAe,CAAC;OACxD;AACD,WAAK,2BAA2B,kBAAkB,IAAI,CAAC,WAAU;AAC7D,eAAO,UAAU,cAAc,kBAAkB,iBAAiB;MACtE,CAAC;AAED,WAAK,2BAA2B,IAAI,oBAAoB,qBAAqB,IAAI,QAAQ,GAAG,CAAG,GAAG,KAAK,SAAS,kBAAkB;QAC9H,cAAc,QAAQ;QACtB,QAAQ,KAAK,OAAO,UAAS;QAC7B,eAAe,KAAK,iBAAiB,eAAe,CAAC;OACxD;AACD,WAAK,yBAAyB,kBAAkB,IAAI,CAAC,WAAU;AAC3D,eAAO,UAAU,cAAc,kBAAkB,iBAAiB;MACtE,CAAC;AAED,WAAK,iBAAiB,CAAC,KAAK,wBAAwB,KAAK,4BAA4B,KAAK,wBAAwB;IACtH,OAAO;AACH,WAAK,6BAA6B,IAAI,gBAAgB,qBAAqB,IAAI,QAAQ,GAAK,CAAC,GAAG,KAAK,SAAS,qBAAqB,GAAG;QAClI,MAAM;UACF,OAAO;UACP,QAAQ;;QAEZ,cAAc,QAAQ;QACtB,QAAQ,KAAK,OAAO,UAAS;QAC7B;QACA,eAAe,KAAK,iBAAiB,eAAe,CAAC;OACxD;AACD,WAAK,2BAA2B,QAAQ;AACxC,WAAK,2BAA2B,SAAS;AACzC,WAAK,2BAA2B,gCAAgC;AAChE,WAAK,2BAA2B,kBAAkB,IAAI,CAAC,WAAU;AAC7D,eAAO,WAAW,kBAAkB,KAAK,YAAY;MACzD,CAAC;AAED,WAAK,2BAA2B,IAAI,gBAAgB,qBAAqB,IAAI,QAAQ,GAAG,CAAG,GAAG,KAAK,SAAS,mBAAmB,GAAG;QAC9H,MAAM;UACF,OAAO;UACP,QAAQ;;QAEZ,cAAc,QAAQ;QACtB,QAAQ,KAAK,OAAO,UAAS;QAC7B;OACH;AAED,WAAK,iBAAiB,CAAC,KAAK,4BAA4B,KAAK,wBAAwB;IACzF;AAEA,SAAK,aAAa,wBAAwB,IAAI,MAAK;AAC/C,WAAK,uBAAuB,gBAAgB,IAAI;AAEhD,YAAM,kBAAkB,KAAK,aAAa;AAC1C,UAAI,iBAAiB;AACjB,aAAK,OAAO,mBAAmB,aAAa,KAAK,gBAAgB,iBAAiB,IAAI;AACtF,aAAK,QAAQ,kBAAkB,iBAAiB,IAAI;MACxD;AAEA,WAAK,sBAAsB,gBAAgB,IAAI;IACnD,CAAC;AAGD,SAAK,eAAe,IAAI,CAAC,OAAM;AAC3B,SAAG,YAAY;IACnB,CAAC;EACL;;;;EAKO,cAAW;AACd,WAAO,KAAK,iBAAiB,YAAW;EAC5C;;;;;;;EAQO,QAAQ,SAAkB,cAAqB;AAClD,WAAO,KAAK,iBAAiB,QAAQ,SAAS,YAAY;EAC9D;;;;;;EAOU,gBAAgB,QAAgB,aAAmB;AACzD,SAAK,iBAAiB,iBAAiB,QAAQ,WAAW;EAC9D;;;;EAKgB,eAAY;AACxB,WAAO,KAAK,iBAAiB,aAAY;EAC7C;;;;;;EAOmB,kBAAkB,MAAU;AAC3C,WAAO,KAAK,iBAAiB,kBAAkB,IAAI;EACvD;;;;;;;EAQmB,eAAe,MAAoB,UAAkB;AACpE,WAAO,KAAK,iBAAiB,eAAe,MAAM,QAAQ;EAC9D;;;;;EAMmB,wBAAwB,SAAiB;AACxD,SAAK,iBAAiB,wBAAwB,OAAO;EACzD;;;;;;;EAQU,4BAA4B,MAAY,SAAkB,UAAkB;AAClF,SAAK,iBAAiB,4BAA4B,MAAM,SAAS,QAAQ;EAC7E;;;;;EAMO,gBAAgB,MAAU;AAC7B,SAAK,iBAAiB,gBAAgB,IAAI;EAC9C;;;;;EAMO,mBAAmB,MAAU;AAChC,SAAK,iBAAiB,mBAAmB,IAAI;EACjD;;;;;;EAOgB,QAAQ,MAAkB;AACtC,WAAO,KAAK,iBAAiB,QAAQ,IAAI;EAC7C;;;;;;;EAQO,QAAQ,MAAY,OAAe,mBAAmB,OAAK;AAC9D,SAAK,iBAAiB,QAAQ,MAAM,OAAO,gBAAgB;EAC/D;;;;;EAMO,WAAW,MAAU;AACxB,SAAK,iBAAiB,WAAW,IAAI;EACzC;;;;EAKO,kBAAe;AAClB,SAAK,iBAAiB,gBAAe;EACzC;;;;;;;EAQO,aAAa,MAAU;AAC1B,SAAK,iBAAiB,aAAa,IAAI;EAC3C;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;;EAMO,YAAS;AACZ,UAAM,sBAAsB,oBAAoB,UAAU,IAAI;AAC9D,wBAAoB,aAAa;AAGjC,wBAAoB,SAAS,CAAA;AAE7B,UAAM,SAAS,KAAK,iBAAiB;AACrC,QAAI,QAAQ;AACR,iBAAW,KAAK,QAAQ;AACpB,cAAM,OAAO,OAAO,CAAC;AAErB,YAAI,MAAM;AACN,8BAAoB,OAAO,KAAK;YAC5B,kBAAkB,KAAK;YACvB,OAAO,KAAK,MAAM,QAAO;YACzB,QAAQ,KAAK,KAAK;WACrB;QACL;MACJ;IACJ;AAGA,wBAAoB,iBAAiB,CAAA;AAErC,UAAM,iBAAiB,KAAK,iBAAiB;AAC7C,QAAI,gBAAgB;AAChB,iBAAW,KAAK,gBAAgB;AAC5B,cAAM,eAAe,eAAe,CAAC;AAErC,YAAI,cAAc;AACd,8BAAoB,eAAe,KAAK,aAAa,KAAK,EAAE;QAChE;MACJ;IACJ;AAEA,WAAO;EACX;;;;;;;;EASO,OAAgB,MAAM,uBAA4B,OAAc,SAAe;AAClF,UAAM,KAAK,oBAAoB,MAAM,MAAM,IAAI,gBAAe,sBAAsB,MAAM,OAAO,sBAAsB,OAAO,GAAG,uBAAuB,OAAO,OAAO;AACtK,QAAI;AAGJ,SAAK,QAAQ,GAAG,QAAQ,sBAAsB,eAAe,QAAQ,SAAS;AAC1E,YAAM,OAAO,MAAM,YAAY,sBAAsB,eAAe,KAAK,CAAC;AAC1E,UAAI,MAAM;AACN,WAAG,gBAAsB,IAAI;MACjC;IACJ;AAGA,SAAK,QAAQ,GAAG,QAAQ,sBAAsB,OAAO,QAAQ,SAAS;AAClE,YAAM,kBAAkB,sBAAsB,OAAO,KAAK;AAC1D,YAAM,OAAO,MAAM,YAAY,gBAAgB,MAAM;AAErD,UAAI,MAAM;AACN,WAAG,QAAc,MAAM,OAAO,UAAU,gBAAgB,KAAK,GAAG,gBAAgB,gBAAgB;MACpG;IACJ;AAEA,WAAO;EACX;;AA9duB,eAAA,aAAa;AAkBpC,WAAA;EADC,UAAS;;AAaV,WAAA;EADC,UAAS;;AA2BV,WAAA;EADC,UAAS;;AASV,WAAA;EADC,UAAS;;AAgBF,WAAA;EADP,UAAU,SAAS;;AAmZxB,cAAc,0BAA0B,cAAc;",
  "names": ["mesh"]
}
