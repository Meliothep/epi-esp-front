{
  "version": 3,
  "sources": ["../../../dev/core/src/Collisions/intersectionInfo.ts", "../../../dev/core/src/Culling/boundingBox.ts", "../../../dev/core/src/Culling/boundingSphere.ts", "../../../dev/core/src/Culling/boundingInfo.ts", "../../../dev/core/src/Maths/math.functions.ts", "../../../dev/core/src/Meshes/subMesh.ts", "../../../dev/core/src/Materials/clipPlaneMaterialHelper.ts", "../../../dev/core/src/Materials/materialHelper.functions.ts", "../../../dev/core/src/Materials/materialStencilState.ts", "../../../dev/core/src/Materials/material.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class IntersectionInfo {\r\n    public faceId = 0;\r\n    public subMeshId = 0;\r\n\r\n    constructor(\r\n        public bu: Nullable<number>,\r\n        public bv: Nullable<number>,\r\n        public distance: number\r\n    ) {}\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in local space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in world space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Class used to store bounding sphere information\r\n */\r\nexport class BoundingSphere {\r\n    /**\r\n     * Gets the center of the bounding sphere in local space\r\n     */\r\n    public readonly center = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in local space\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Gets the center of the bounding sphere in world space\r\n     */\r\n    public readonly centerWorld = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in world space\r\n     */\r\n    public radiusWorld: number;\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * Creates a new bounding sphere\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.minimum.copyFrom(min);\r\n        this.maximum.copyFrom(max);\r\n\r\n        const distance = Vector3.Distance(min, max);\r\n\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        this.radius = distance * 0.5;\r\n\r\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding sphere by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingSphere {\r\n        const newRadius = this.radius * factor;\r\n        const tmpVectors = BoundingSphere._TmpVector3;\r\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\r\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\r\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(worldMatrix: DeepImmutable<Matrix>): void {\r\n        if (!worldMatrix.isIdentity()) {\r\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\r\n            const tempVector = BoundingSphere._TmpVector3[0];\r\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\r\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\r\n        } else {\r\n            this.centerWorld.copyFrom(this.center);\r\n            this.radiusWorld = this.radius;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        const radius = this.radiusWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere center is in between the frustum planes.\r\n     * Used for optimistic fast inclusion.\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the sphere center is in between the frustum planes\r\n     */\r\n    public isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding sphere\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding sphere\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\r\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Checks if two sphere intersect\r\n     * @param sphere0 sphere 0\r\n     * @param sphere1 sphere 1\r\n     * @returns true if the spheres intersect\r\n     */\r\n    public static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\r\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\r\n\r\n        if (radiusSum * radiusSum < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a sphere from a center and a radius\r\n     * @param center The center\r\n     * @param radius radius\r\n     * @param matrix Optional worldMatrix\r\n     * @returns The sphere\r\n     */\r\n    public static CreateFromCenterAndRadius(center: DeepImmutable<Vector3>, radius: number, matrix?: DeepImmutable<Matrix>): BoundingSphere {\r\n        this._TmpVector3[0].copyFrom(center);\r\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\r\n        this._TmpVector3[2].copyFrom(center);\r\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\r\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\r\n\r\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\r\n\r\n        if (matrix) {\r\n            sphere._worldMatrix = matrix;\r\n        } else {\r\n            sphere._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { TmpVectors } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info (in local space)\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        const invw = TmpVectors.Matrix[0];\r\n        this.boundingBox.getWorldMatrix().invertToRef(invw);\r\n\r\n        const v = TmpVectors.Vector3[0];\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import type { FloatArray, Nullable, IndicesArray } from \"../types\";\r\nimport type { Vector2 } from \"./math.vector\";\r\nimport { Vector3 } from \"./math.vector\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\n\r\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\r\nclass MathHelpers {\r\n    @nativeOverride.filter((...[positions, indices]: Parameters<typeof MathHelpers.extractMinAndMaxIndexed>) => !Array.isArray(positions) && !Array.isArray(indices))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\r\n            const offset = indices[index] * 3;\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[positions]: Parameters<typeof MathHelpers.extractMinAndMax>) => !Array.isArray(positions))\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static extractMinAndMax(positions: FloatArray, start: number, count: number, stride: number, minimum: Vector3, maximum: Vector3): void {\r\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\r\n            const x = positions[offset];\r\n            const y = positions[offset + 1];\r\n            const z = positions[offset + 2];\r\n            minimum.minimizeInPlaceFromFloats(x, y, z);\r\n            maximum.maximizeInPlaceFromFloats(x, y, z);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of indexed positions\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to the positions\r\n * @param indexStart defines the start index\r\n * @param indexCount defines the end index\r\n * @param bias defines bias value to add to the result\r\n * @returns minimum and maximum values\r\n */\r\nexport function extractMinAndMaxIndexed(\r\n    positions: FloatArray,\r\n    indices: IndicesArray,\r\n    indexStart: number,\r\n    indexCount: number,\r\n    bias: Nullable<Vector2> = null\r\n): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Extracts minimum and maximum values from a list of positions\r\n * @param positions defines the positions to use\r\n * @param start defines the start index in the positions array\r\n * @param count defines the number of positions to handle\r\n * @param bias defines bias value to add to the result\r\n * @param stride defines the stride size to use (distance between two positions in the positions array)\r\n * @returns minimum and maximum values\r\n */\r\nexport function extractMinAndMax(positions: FloatArray, start: number, count: number, bias: Nullable<Vector2> = null, stride?: number): { minimum: Vector3; maximum: Vector3 } {\r\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n    if (!stride) {\r\n        stride = 3;\r\n    }\r\n\r\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\r\n\r\n    if (bias) {\r\n        minimum.x -= minimum.x * bias.x + bias.y;\r\n        minimum.y -= minimum.y * bias.x + bias.y;\r\n        minimum.z -= minimum.z * bias.x + bias.y;\r\n        maximum.x += maximum.x * bias.x + bias.y;\r\n        maximum.y += maximum.y * bias.x + bias.y;\r\n        maximum.z += maximum.z * bias.x + bias.y;\r\n    }\r\n\r\n    return {\r\n        minimum: minimum,\r\n        maximum: maximum,\r\n    };\r\n}\r\n\r\n/**\r\n * Flip flipped faces\r\n * @param positions defines the positions to use\r\n * @param indices defines the indices to use and update\r\n */\r\nexport function FixFlippedFaces(positions: FloatArray, indices: IndicesArray): void {\r\n    const boundingInfo = extractMinAndMax(positions!, 0, positions!.length / 3);\r\n\r\n    const inside = boundingInfo.maximum.subtract(boundingInfo.minimum).scale(0.5).add(boundingInfo.minimum);\r\n    const tmpVectorA = new Vector3();\r\n    const tmpVectorB = new Vector3();\r\n    const tmpVectorC = new Vector3();\r\n    const tmpVectorAB = new Vector3();\r\n    const tmpVectorAC = new Vector3();\r\n    const tmpVectorNormal = new Vector3();\r\n    const tmpVectorAvgNormal = new Vector3();\r\n\r\n    // Clean indices\r\n    for (let index = 0; index < indices.length; index += 3) {\r\n        const a = indices[index];\r\n        const b = indices[index + 1];\r\n        const c = indices[index + 2];\r\n\r\n        // Evaluate face normal\r\n        tmpVectorA.fromArray(positions, a * 3);\r\n        tmpVectorB.fromArray(positions, b * 3);\r\n        tmpVectorC.fromArray(positions, c * 3);\r\n\r\n        tmpVectorB.subtractToRef(tmpVectorA, tmpVectorAB);\r\n        tmpVectorC.subtractToRef(tmpVectorA, tmpVectorAC);\r\n\r\n        Vector3.CrossToRef(tmpVectorAB, tmpVectorAC, tmpVectorNormal);\r\n\r\n        tmpVectorNormal.normalize();\r\n\r\n        // Calculate normal from face center to the inside of the geometry\r\n        const avgX = tmpVectorA.x + tmpVectorB.x + tmpVectorC.x;\r\n        const avgY = tmpVectorA.y + tmpVectorB.y + tmpVectorC.y;\r\n        const avgZ = tmpVectorA.z + tmpVectorB.z + tmpVectorC.z;\r\n\r\n        tmpVectorAvgNormal.set(avgX / 3, avgY / 3, avgZ / 3);\r\n        tmpVectorAvgNormal.subtractInPlace(inside);\r\n        tmpVectorAvgNormal.normalize();\r\n\r\n        if (Vector3.Dot(tmpVectorNormal, tmpVectorAvgNormal) >= 0) {\r\n            // Flip!\r\n            indices[index] = c;\r\n            indices[index + 2] = a;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { Mesh } from \"./mesh\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true, immediate = false): void {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose(immediate);\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (this._getDrawWrapper()?.effect ?? null);\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     * @param immediate If true, the draw wrapper will dispose the effect immediately (false by default)\r\n     */\r\n    public resetDrawCache(passId?: number, immediate = false): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId, true, immediate);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose(immediate);\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal || this._mesh.hasThinInstances) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial && this._mesh.getScene()._hasDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: AbstractEngine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const adjustedIndexCount = Math.floor(this.indexCount / 3) * 6;\r\n            const shouldUseUint32 = this.verticesStart + this.verticesCount > 65535;\r\n            const linesIndices = shouldUseUint32 ? new Uint32Array(adjustedIndexCount) : new Uint16Array(adjustedIndexCount);\r\n\r\n            let offset = 0;\r\n            if (indices.length === 0) {\r\n                // Unindexed mesh\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = index;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index;\r\n                }\r\n            } else {\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = indices[index];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index];\r\n                }\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     * @param immediate If true, the effect will be disposed immediately (false by default)\r\n     */\r\n    public dispose(immediate = false): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache(undefined, immediate);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n", "import type { Effect } from \"./effect\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/** @internal */\r\nexport function addClipPlaneUniforms(uniforms: string[]): void {\r\n    if (uniforms.indexOf(\"vClipPlane\") === -1) {\r\n        uniforms.push(\"vClipPlane\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane2\") === -1) {\r\n        uniforms.push(\"vClipPlane2\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane3\") === -1) {\r\n        uniforms.push(\"vClipPlane3\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane4\") === -1) {\r\n        uniforms.push(\"vClipPlane4\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane5\") === -1) {\r\n        uniforms.push(\"vClipPlane5\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane6\") === -1) {\r\n        uniforms.push(\"vClipPlane6\");\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function prepareStringDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: string[]): void {\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    if (clipPlane) defines.push(\"#define CLIPPLANE\");\r\n    if (clipPlane2) defines.push(\"#define CLIPPLANE2\");\r\n    if (clipPlane3) defines.push(\"#define CLIPPLANE3\");\r\n    if (clipPlane4) defines.push(\"#define CLIPPLANE4\");\r\n    if (clipPlane5) defines.push(\"#define CLIPPLANE5\");\r\n    if (clipPlane6) defines.push(\"#define CLIPPLANE6\");\r\n}\r\n\r\n/** @internal */\r\nexport function prepareDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: Record<string, any>): boolean {\r\n    let changed = false;\r\n\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    // Do not factorize this code, it breaks browsers optimizations.\r\n    if (defines[\"CLIPPLANE\"] !== clipPlane) {\r\n        defines[\"CLIPPLANE\"] = clipPlane;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE2\"] !== clipPlane2) {\r\n        defines[\"CLIPPLANE2\"] = clipPlane2;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE3\"] !== clipPlane3) {\r\n        defines[\"CLIPPLANE3\"] = clipPlane3;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE4\"] !== clipPlane4) {\r\n        defines[\"CLIPPLANE4\"] = clipPlane4;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE5\"] !== clipPlane5) {\r\n        defines[\"CLIPPLANE5\"] = clipPlane5;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE6\"] !== clipPlane6) {\r\n        defines[\"CLIPPLANE6\"] = clipPlane6;\r\n        changed = true;\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/** @internal */\r\nexport function bindClipPlane(effect: Effect, primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder): void {\r\n    let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;\r\n    setClipPlane(effect, \"vClipPlane\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;\r\n    setClipPlane(effect, \"vClipPlane2\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;\r\n    setClipPlane(effect, \"vClipPlane3\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;\r\n    setClipPlane(effect, \"vClipPlane4\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;\r\n    setClipPlane(effect, \"vClipPlane5\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;\r\n    setClipPlane(effect, \"vClipPlane6\", clipPlane);\r\n}\r\n\r\nfunction setClipPlane(effect: Effect, uniformName: string, clipPlane: Nullable<Plane>): void {\r\n    if (clipPlane) {\r\n        effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Material } from \"./material\";\r\nimport type { Nullable } from \"../types\";\r\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\nimport type { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\n\r\n// Temps\r\nconst _TempFogColor = Color3.Black();\r\nconst _TmpMorphInfluencers = {\r\n    NUM_MORPH_INFLUENCERS: 0,\r\n    NORMAL: false,\r\n    TANGENT: false,\r\n    UV: false,\r\n    UV2: false,\r\n    COLOR: false,\r\n};\r\n\r\n/**\r\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n * @param defines The generated defines used in the effect\r\n * @param effect The effect we are binding the data to\r\n * @param scene The scene we are willing to render with logarithmic scale for\r\n */\r\nexport function BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\r\n        const camera = scene.activeCamera as Camera;\r\n        if (camera.mode === Constants.ORTHOGRAPHIC_CAMERA) {\r\n            Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n        }\r\n        effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the fog information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param linearSpace Defines if the fog effect is applied in linear space\r\n */\r\nexport function BindFogParameters(scene: Scene, mesh?: AbstractMesh, effect?: Effect, linearSpace = false): void {\r\n    if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== Constants.FOGMODE_NONE) {\r\n        effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n        // Convert fog color to linear space if used in a linear space computed shader.\r\n        if (linearSpace) {\r\n            scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\r\n            effect.setColor3(\"vFogColor\", _TempFogColor);\r\n        } else {\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes and defines required for morph targets.\r\n * @param morphTargetManager The manager for the morph targets\r\n * @param defines The current list of defines\r\n * @param attribs The current list of attributes\r\n * @param mesh The mesh to prepare the defines and attributes for\r\n * @param usePositionMorph Whether the position morph target is used\r\n * @param useNormalMorph Whether the normal morph target is used\r\n * @param useTangentMorph Whether the tangent morph target is used\r\n * @param useUVMorph Whether the UV morph target is used\r\n * @param useUV2Morph Whether the UV2 morph target is used\r\n * @param useColorMorph Whether the color morph target is used\r\n * @returns The maxSimultaneousMorphTargets for the effect\r\n */\r\nexport function PrepareDefinesAndAttributesForMorphTargets(\r\n    morphTargetManager: MorphTargetManager,\r\n    defines: string[],\r\n    attribs: string[],\r\n    mesh: AbstractMesh,\r\n    usePositionMorph: boolean,\r\n    useNormalMorph: boolean,\r\n    useTangentMorph: boolean,\r\n    useUVMorph: boolean,\r\n    useUV2Morph: boolean,\r\n    useColorMorph: boolean\r\n): number {\r\n    const numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;\r\n    if (numMorphInfluencers <= 0) {\r\n        return 0;\r\n    }\r\n\r\n    defines.push(\"#define MORPHTARGETS\");\r\n\r\n    if (morphTargetManager.hasPositions) defines.push(\"#define MORPHTARGETTEXTURE_HASPOSITIONS\");\r\n    if (morphTargetManager.hasNormals) defines.push(\"#define MORPHTARGETTEXTURE_HASNORMALS\");\r\n    if (morphTargetManager.hasTangents) defines.push(\"#define MORPHTARGETTEXTURE_HASTANGENTS\");\r\n    if (morphTargetManager.hasUVs) defines.push(\"#define MORPHTARGETTEXTURE_HASUVS\");\r\n    if (morphTargetManager.hasUV2s) defines.push(\"#define MORPHTARGETTEXTURE_HASUV2S\");\r\n    if (morphTargetManager.hasColors) defines.push(\"#define MORPHTARGETTEXTURE_HASCOLORS\");\r\n\r\n    if (morphTargetManager.supportsPositions && usePositionMorph) defines.push(\"#define MORPHTARGETS_POSITION\");\r\n    if (morphTargetManager.supportsNormals && useNormalMorph) defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n    if (morphTargetManager.supportsTangents && useTangentMorph) defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n    if (morphTargetManager.supportsUVs && useUVMorph) defines.push(\"#define MORPHTARGETS_UV\");\r\n    if (morphTargetManager.supportsUV2s && useUV2Morph) defines.push(\"#define MORPHTARGETS_UV2\");\r\n    if (morphTargetManager.supportsColors && useColorMorph) defines.push(\"#define MORPHTARGETS_COLOR\");\r\n\r\n    defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n    if (morphTargetManager.isUsingTextureForTargets) {\r\n        defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n    }\r\n\r\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = numMorphInfluencers;\r\n    _TmpMorphInfluencers.NORMAL = useNormalMorph;\r\n    _TmpMorphInfluencers.TANGENT = useTangentMorph;\r\n    _TmpMorphInfluencers.UV = useUVMorph;\r\n    _TmpMorphInfluencers.UV2 = useUV2Morph;\r\n    _TmpMorphInfluencers.COLOR = useColorMorph;\r\n\r\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers, usePositionMorph);\r\n    return numMorphInfluencers;\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param influencers The number of influencers\r\n */\r\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n    _TmpMorphInfluencers.NORMAL = false;\r\n    _TmpMorphInfluencers.TANGENT = false;\r\n    _TmpMorphInfluencers.UV = false;\r\n    _TmpMorphInfluencers.UV2 = false;\r\n    _TmpMorphInfluencers.COLOR = false;\r\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers, true);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param defines The current Defines of the effect\r\n * @param usePositionMorph Whether the position morph target is used\r\n */\r\nexport function PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any, usePositionMorph = true): void {\r\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n        const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n        const manager = (mesh as Mesh).morphTargetManager;\r\n        if (manager?.isUsingTextureForTargets) {\r\n            return;\r\n        }\r\n        const position = manager && manager.supportsPositions && usePositionMorph;\r\n        const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n        const uv2 = manager && manager.supportsUV2s && defines[\"UV2\"];\r\n        const color = manager && manager.supportsColors && defines[\"COLOR\"];\r\n        for (let index = 0; index < influencers; index++) {\r\n            if (position) {\r\n                attribs.push(Constants.PositionKind + index);\r\n            }\r\n\r\n            if (normal) {\r\n                attribs.push(Constants.NormalKind + index);\r\n            }\r\n\r\n            if (tangent) {\r\n                attribs.push(Constants.TangentKind + index);\r\n            }\r\n\r\n            if (uv) {\r\n                attribs.push(Constants.UVKind + \"_\" + index);\r\n            }\r\n\r\n            if (uv2) {\r\n                attribs.push(Constants.UV2Kind + \"_\" + index);\r\n            }\r\n\r\n            if (color) {\r\n                attribs.push(Constants.ColorKind + index);\r\n            }\r\n\r\n            if (attribs.length > maxAttributesCount) {\r\n                Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Add the list of attributes required for instances to the attribs array.\r\n * @param attribs The current list of supported attribs\r\n * @param needsPreviousMatrices If the shader needs previous matrices\r\n */\r\nexport function PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n    attribs.push(\"world0\");\r\n    attribs.push(\"world1\");\r\n    attribs.push(\"world2\");\r\n    attribs.push(\"world3\");\r\n    if (needsPreviousMatrices) {\r\n        attribs.push(\"previousWorld0\");\r\n        attribs.push(\"previousWorld1\");\r\n        attribs.push(\"previousWorld2\");\r\n        attribs.push(\"previousWorld3\");\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the morph targets information from the mesh to the effect.\r\n * @param abstractMesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n */\r\nexport function BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n    const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n    if (!abstractMesh || !manager) {\r\n        return;\r\n    }\r\n\r\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n}\r\n\r\n/**\r\n * Binds the scene's uniform buffer to the effect.\r\n * @param effect defines the effect to bind to the scene uniform buffer\r\n * @param sceneUbo defines the uniform buffer storing scene data\r\n */\r\nexport function BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n    sceneUbo.bindToEffect(effect, \"Scene\");\r\n}\r\n\r\n/**\r\n * Helps preparing the defines values about the UVs in used in the effect.\r\n * UVs are shared as much as we can across channels in the shaders.\r\n * @param texture The texture we are preparing the UVs for\r\n * @param defines The defines to update\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n    defines._needUVs = true;\r\n    defines[key] = true;\r\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\r\n        defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n        defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n    } else {\r\n        defines[key + \"DIRECTUV\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Binds a texture matrix value to its corresponding uniform\r\n * @param texture The texture to bind the matrix for\r\n * @param uniformBuffer The uniform buffer receiving the data\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n    const matrix = texture.getTextureMatrix();\r\n\r\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare for baked vertex animations\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n    if (enabled) {\r\n        attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n    }\r\n}\r\n\r\n// Copies the bones transformation matrices into the target array and returns the target's reference\r\nfunction _CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n    target.set(source);\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n * Binds the bones information from the mesh to the effect.\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n */\r\nexport function BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n    if (!effect || !mesh) {\r\n        return;\r\n    }\r\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n        mesh.computeBonesUsingShaders = false;\r\n    }\r\n\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        const skeleton = mesh.skeleton;\r\n\r\n        if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n            const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n            effect.setTexture(\"boneSampler\", boneTexture);\r\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n        } else {\r\n            const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n            if (matrices) {\r\n                effect.setMatrices(\"mBones\", matrices);\r\n                if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                    if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                        prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                    }\r\n                    effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the light information to the effect.\r\n * @param light The light containing the generator\r\n * @param effect The effect we are binding the data to\r\n * @param lightIndex The light index in the effect used to render\r\n */\r\nexport function BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n    light.transferToEffect(effect, lightIndex + \"\");\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param light Light to bind\r\n * @param lightIndex Light index\r\n * @param scene The scene where the light belongs to\r\n * @param effect The effect we are binding the data to\r\n * @param useSpecular Defines if specular is supported\r\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n */\r\nexport function BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param defines The generated defines for the effect\r\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n */\r\nexport function BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        const light = mesh.lightSources[i];\r\n        BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for bones according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the bones attributes for\r\n * @param defines The current Defines of the effect\r\n * @param fallbacks The current effect fallback strategy\r\n */\r\nexport function PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n        fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n        attribs.push(Constants.MatricesIndicesKind);\r\n        attribs.push(Constants.MatricesWeightsKind);\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n            attribs.push(Constants.MatricesIndicesExtraKind);\r\n            attribs.push(Constants.MatricesWeightsExtraKind);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check and prepare the list of attributes required for instances according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param defines The current MaterialDefines of the effect\r\n */\r\nexport function PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n        PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n    }\r\n\r\n    if (defines.INSTANCESCOLOR) {\r\n        attribs.push(Constants.ColorInstanceKind);\r\n    }\r\n}\r\n\r\n/**\r\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n * @param defines The defines to update while falling back\r\n * @param fallbacks The authorized effect fallbacks\r\n * @param maxSimultaneousLights The maximum number of lights allowed\r\n * @param rank the current rank of the Effect\r\n * @returns The newly affected rank\r\n */\r\nexport function HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n    let lightFallbackRank = 0;\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n\r\n        if (lightIndex > 0) {\r\n            lightFallbackRank = rank + lightIndex;\r\n            fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n        }\r\n\r\n        if (!defines[\"SHADOWS\"]) {\r\n            if (defines[\"SHADOW\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n            }\r\n        }\r\n    }\r\n    return lightFallbackRank++;\r\n}\r\n\r\n/**\r\n * Gets the current status of the fog (should it be enabled?)\r\n * @param mesh defines the mesh to evaluate for fog support\r\n * @param scene defines the hosting scene\r\n * @returns true if fog must be enabled\r\n */\r\nexport function GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Constants.FOGMODE_NONE;\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n * @param mesh defines the current mesh\r\n * @param scene defines the current scene\r\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n * @param pointsCloud defines if point cloud rendering has to be turned on\r\n * @param fogEnabled defines if fog has to be turned on\r\n * @param alphaTest defines if alpha testing has to be turned on\r\n * @param defines defines the current list of defines\r\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n */\r\nexport function PrepareDefinesForMisc(\r\n    mesh: AbstractMesh,\r\n    scene: Scene,\r\n    useLogarithmicDepth: boolean,\r\n    pointsCloud: boolean,\r\n    fogEnabled: boolean,\r\n    alphaTest: boolean,\r\n    defines: any,\r\n    applyDecalAfterDetail: boolean = false\r\n): void {\r\n    if (defines._areMiscDirty) {\r\n        defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n        defines[\"POINTSIZE\"] = pointsCloud;\r\n        defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\r\n        defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n        defines[\"ALPHATEST\"] = alphaTest;\r\n        defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n * @returns true if normals will be required for the rest of the effect\r\n */\r\nexport function PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n    if (!defines._areLightsDirty) {\r\n        return defines._needNormals;\r\n    }\r\n\r\n    let lightIndex = 0;\r\n    const state = {\r\n        needNormals: defines._needNormals, // prevents overriding previous reflection or other needs for normals\r\n        needRebuild: false,\r\n        lightmapMode: false,\r\n        shadowEnabled: false,\r\n        specularEnabled: false,\r\n    };\r\n\r\n    if (scene.lightsEnabled && !disableLighting) {\r\n        for (const light of mesh.lightSources) {\r\n            PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n            lightIndex++;\r\n            if (lightIndex === maxSimultaneousLights) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n    defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n    // Resetting all other lights if any\r\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\r\n        if (defines[\"LIGHT\" + index] !== undefined) {\r\n            defines[\"LIGHT\" + index] = false;\r\n            defines[\"HEMILIGHT\" + index] = false;\r\n            defines[\"POINTLIGHT\" + index] = false;\r\n            defines[\"DIRLIGHT\" + index] = false;\r\n            defines[\"SPOTLIGHT\" + index] = false;\r\n            defines[\"AREALIGHT\" + index] = false;\r\n            defines[\"SHADOW\" + index] = false;\r\n            defines[\"SHADOWCSM\" + index] = false;\r\n            defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n            defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n            defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n            defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n            defines[\"SHADOWPCF\" + index] = false;\r\n            defines[\"SHADOWPCSS\" + index] = false;\r\n            defines[\"SHADOWPOISSON\" + index] = false;\r\n            defines[\"SHADOWESM\" + index] = false;\r\n            defines[\"SHADOWCLOSEESM\" + index] = false;\r\n            defines[\"SHADOWCUBE\" + index] = false;\r\n            defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n            defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n        }\r\n    }\r\n\r\n    const caps = scene.getEngine().getCaps();\r\n\r\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"SHADOWFLOAT\"] =\r\n        state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n    if (state.needRebuild) {\r\n        defines.rebuild();\r\n    }\r\n\r\n    return state.needNormals;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param light The light the effect is compiling for\r\n * @param lightIndex The index of the light\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param state Defines the current state regarding what is needed (normals, etc...)\r\n * @param state.needNormals\r\n * @param state.needRebuild\r\n * @param state.shadowEnabled\r\n * @param state.specularEnabled\r\n * @param state.lightmapMode\r\n */\r\nexport function PrepareDefinesForLight(\r\n    scene: Scene,\r\n    mesh: AbstractMesh,\r\n    light: Light,\r\n    lightIndex: number,\r\n    defines: any,\r\n    specularSupported: boolean,\r\n    state: {\r\n        needNormals: boolean;\r\n        needRebuild: boolean;\r\n        shadowEnabled: boolean;\r\n        specularEnabled: boolean;\r\n        lightmapMode: boolean;\r\n    }\r\n) {\r\n    state.needNormals = true;\r\n\r\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n    defines[\"HEMILIGHT\" + lightIndex] = false;\r\n    defines[\"POINTLIGHT\" + lightIndex] = false;\r\n    defines[\"DIRLIGHT\" + lightIndex] = false;\r\n    defines[\"AREALIGHT\" + lightIndex] = false;\r\n\r\n    light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n    // FallOff.\r\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n    switch (light.falloffType) {\r\n        case LightConstants.FALLOFF_GLTF:\r\n            defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_PHYSICAL:\r\n            defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_STANDARD:\r\n            defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n            break;\r\n    }\r\n\r\n    // Specular\r\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n        state.specularEnabled = true;\r\n    }\r\n\r\n    // Shadows\r\n    defines[\"SHADOW\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n    defines[\"SHADOWPCF\" + lightIndex] = false;\r\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n    defines[\"SHADOWESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n        const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\r\n        if (shadowGenerator) {\r\n            const shadowMap = shadowGenerator.getShadowMap();\r\n            if (shadowMap) {\r\n                if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                    state.shadowEnabled = true;\r\n                    shadowGenerator.prepareDefines(defines, lightIndex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\r\n        state.lightmapMode = true;\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\r\n    } else {\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n * @param scene defines the current scene\r\n * @param engine defines the current engine\r\n * @param material defines the material we are compiling the shader for\r\n * @param defines specifies the list of active defines\r\n * @param useInstances defines if instances have to be turned on\r\n * @param useClipPlane defines if clip plane have to be turned on\r\n * @param useThinInstances defines if thin instances have to be turned on\r\n */\r\nexport function PrepareDefinesForFrameBoundValues(\r\n    scene: Scene,\r\n    engine: AbstractEngine,\r\n    material: Material,\r\n    defines: any,\r\n    useInstances: boolean,\r\n    useClipPlane: Nullable<boolean> = null,\r\n    useThinInstances: boolean = false\r\n): void {\r\n    let changed = PrepareDefinesForCamera(scene, defines);\r\n\r\n    if (useClipPlane !== false) {\r\n        changed = prepareDefinesForClipPlanes(material, scene, defines);\r\n    }\r\n\r\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n        defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"INSTANCES\"] !== useInstances) {\r\n        defines[\"INSTANCES\"] = useInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n        defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for bones\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n        const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n        if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n            defines[\"BONETEXTURE\"] = true;\r\n        } else {\r\n            defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n            defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n            const prePassRenderer = mesh.getScene().prePassRenderer;\r\n            if (prePassRenderer && prePassRenderer.enabled) {\r\n                const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n            }\r\n        }\r\n    } else {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n        defines[\"BonesPerMesh\"] = 0;\r\n        if (defines[\"BONETEXTURE\"] !== undefined) {\r\n            defines[\"BONETEXTURE\"] = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for morph targets\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).morphTargetManager;\r\n    if (manager) {\r\n        defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n        defines[\"MORPHTARGETS_UV2\"] = manager.supportsUV2s && defines[\"UV2\"];\r\n        defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n        defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n        defines[\"MORPHTARGETS_POSITION\"] = manager.supportsPositions;\r\n        defines[\"MORPHTARGETS_COLOR\"] = manager.supportsColors;\r\n\r\n        defines[\"MORPHTARGETTEXTURE_HASUVS\"] = manager.hasUVs;\r\n        defines[\"MORPHTARGETTEXTURE_HASUV2S\"] = manager.hasUV2s;\r\n        defines[\"MORPHTARGETTEXTURE_HASTANGENTS\"] = manager.hasTangents;\r\n        defines[\"MORPHTARGETTEXTURE_HASNORMALS\"] = manager.hasNormals;\r\n        defines[\"MORPHTARGETTEXTURE_HASPOSITIONS\"] = manager.hasPositions;\r\n        defines[\"MORPHTARGETTEXTURE_HASCOLORS\"] = manager.hasColors;\r\n\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\r\n        defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\r\n\r\n        defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n    } else {\r\n        defines[\"MORPHTARGETS_UV\"] = false;\r\n        defines[\"MORPHTARGETS_UV2\"] = false;\r\n        defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n        defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n        defines[\"MORPHTARGETS_POSITION\"] = false;\r\n        defines[\"MORPHTARGETS_COLOR\"] = false;\r\n\r\n        defines[\"MORPHTARGETTEXTURE_HASUVS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASUV2S\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASTANGENTS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASNORMALS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASPOSITIONS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HAS_COLORS\"] = false;\r\n\r\n        defines[\"MORPHTARGETS\"] = false;\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for baked vertex animation\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n}\r\n\r\n/**\r\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n * @param useBones Precise whether bones should be used or not (override mesh info)\r\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n * @returns false if defines are considered not dirty and have not been checked\r\n */\r\nexport function PrepareDefinesForAttributes(\r\n    mesh: AbstractMesh,\r\n    defines: any,\r\n    useVertexColor: boolean,\r\n    useBones: boolean,\r\n    useMorphTargets = false,\r\n    useVertexAlpha = true,\r\n    useBakedVertexAnimation = true\r\n): boolean {\r\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n        return false;\r\n    }\r\n\r\n    defines._normals = defines._needNormals;\r\n    defines._uvs = defines._needUVs;\r\n\r\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(Constants.NormalKind);\r\n\r\n    if (defines._needNormals && mesh.isVerticesDataPresent(Constants.TangentKind)) {\r\n        defines[\"TANGENT\"] = true;\r\n    }\r\n\r\n    for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n        defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n    }\r\n\r\n    if (useVertexColor) {\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(Constants.ColorKind);\r\n        defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n        defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n    }\r\n\r\n    if (mesh.isVerticesDataPresent(Constants.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\r\n        defines[\"INSTANCESCOLOR\"] = true;\r\n    }\r\n\r\n    if (useBones) {\r\n        PrepareDefinesForBones(mesh, defines);\r\n    }\r\n\r\n    if (useMorphTargets) {\r\n        PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    if (useBakedVertexAnimation) {\r\n        PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to multiview\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n    if (scene.activeCamera) {\r\n        const previousMultiview = defines.MULTIVIEW;\r\n        defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n        if (defines.MULTIVIEW != previousMultiview) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to order independant transparency\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param needAlphaBlending Determines if the material needs alpha blending\r\n */\r\nexport function PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the prepass\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n */\r\nexport function PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n    const previousPrePass = defines.PREPASS;\r\n\r\n    if (!defines._arePrePassDirty) {\r\n        return;\r\n    }\r\n\r\n    const texturesList = [\r\n        {\r\n            type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_POSITION\",\r\n            index: \"PREPASS_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_LOCAL_POSITION\",\r\n            index: \"PREPASS_LOCAL_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY\",\r\n            index: \"PREPASS_VELOCITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY_LINEAR\",\r\n            index: \"PREPASS_VELOCITY_LINEAR_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_REFLECTIVITY\",\r\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n            define: \"PREPASS_IRRADIANCE\",\r\n            index: \"PREPASS_IRRADIANCE_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n            define: \"PREPASS_ALBEDO_SQRT\",\r\n            index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_DEPTH\",\r\n            index: \"PREPASS_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_SCREENSPACE_DEPTH\",\r\n            index: \"PREPASS_SCREENSPACE_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_NORMAL\",\r\n            index: \"PREPASS_NORMAL_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_WORLD_NORMAL\",\r\n            index: \"PREPASS_WORLD_NORMAL_INDEX\",\r\n        },\r\n    ];\r\n\r\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n        defines.PREPASS = true;\r\n        defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n        defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\r\n        defines.PREPASS_COLOR = true;\r\n        defines.PREPASS_COLOR_INDEX = 0;\r\n\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n            if (index !== -1) {\r\n                defines[texturesList[i].define] = true;\r\n                defines[texturesList[i].index] = index;\r\n            } else {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n    } else {\r\n        defines.PREPASS = false;\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            defines[texturesList[i].define] = false;\r\n        }\r\n    }\r\n\r\n    if (defines.PREPASS != previousPrePass) {\r\n        defines.markAsUnprocessed();\r\n        defines.markAsImageProcessingDirty();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the defines relative to the active camera\r\n * @param scene defines the current scene\r\n * @param defines specifies the list of active defines\r\n * @returns true if the defines have been updated, else false\r\n */\r\nexport function PrepareDefinesForCamera(scene: Scene, defines: any): boolean {\r\n    let changed = false;\r\n\r\n    if (scene.activeCamera) {\r\n        const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\r\n        const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\r\n        const isOrtho = scene.activeCamera.mode === Constants.ORTHOGRAPHIC_CAMERA ? 1 : 0;\r\n        const isPersp = scene.activeCamera.mode === Constants.PERSPECTIVE_CAMERA ? 1 : 0;\r\n\r\n        if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\r\n            defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\r\n            defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n * @param lightIndex defines the light index\r\n * @param uniformsList The uniform list\r\n * @param samplersList The sampler list\r\n * @param projectedLightTexture defines if projected texture must be used\r\n * @param uniformBuffersList defines an optional list of uniform buffers\r\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n * @param iesLightTexture defines if IES texture must be used\r\n */\r\nexport function PrepareUniformsAndSamplersForLight(\r\n    lightIndex: number,\r\n    uniformsList: string[],\r\n    samplersList: string[],\r\n    projectedLightTexture?: any,\r\n    uniformBuffersList: Nullable<string[]> = null,\r\n    updateOnlyBuffersList = false,\r\n    iesLightTexture = false\r\n) {\r\n    if (uniformBuffersList) {\r\n        uniformBuffersList.push(\"Light\" + lightIndex);\r\n    }\r\n\r\n    if (updateOnlyBuffersList) {\r\n        return;\r\n    }\r\n\r\n    uniformsList.push(\r\n        \"vLightData\" + lightIndex,\r\n        \"vLightDiffuse\" + lightIndex,\r\n        \"vLightSpecular\" + lightIndex,\r\n        \"vLightDirection\" + lightIndex,\r\n        \"vLightWidth\" + lightIndex,\r\n        \"vLightHeight\" + lightIndex,\r\n        \"vLightFalloff\" + lightIndex,\r\n        \"vLightGround\" + lightIndex,\r\n        \"lightMatrix\" + lightIndex,\r\n        \"shadowsInfo\" + lightIndex,\r\n        \"depthValues\" + lightIndex\r\n    );\r\n\r\n    samplersList.push(\"shadowTexture\" + lightIndex);\r\n    samplersList.push(\"depthTexture\" + lightIndex);\r\n\r\n    uniformsList.push(\r\n        \"viewFrustumZ\" + lightIndex,\r\n        \"cascadeBlendFactor\" + lightIndex,\r\n        \"lightSizeUVCorrection\" + lightIndex,\r\n        \"depthCorrection\" + lightIndex,\r\n        \"penumbraDarkness\" + lightIndex,\r\n        \"frustumLengths\" + lightIndex\r\n    );\r\n\r\n    if (projectedLightTexture) {\r\n        samplersList.push(\"projectionLightTexture\" + lightIndex);\r\n        uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n    }\r\n    if (iesLightTexture) {\r\n        samplersList.push(\"iesLightTexture\" + lightIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect\r\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n * @param samplersList The sampler list\r\n * @param defines The defines helping in the list generation\r\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n */\r\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n    let uniformsList: string[];\r\n    let uniformBuffersList: string[] | undefined;\r\n\r\n    if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n        const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n        uniformsList = options.uniformsNames;\r\n        uniformBuffersList = options.uniformBuffersNames;\r\n        samplersList = options.samplers;\r\n        defines = options.defines;\r\n        maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n    } else {\r\n        uniformsList = <string[]>uniformsListOrOptions;\r\n        if (!samplersList) {\r\n            samplersList = [];\r\n        }\r\n    }\r\n\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n        PrepareUniformsAndSamplersForLight(\r\n            lightIndex,\r\n            uniformsList,\r\n            samplersList,\r\n            defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n            uniformBuffersList,\r\n            false,\r\n            defines[\"IESLIGHTTEXTURE\" + lightIndex]\r\n        );\r\n    }\r\n\r\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n        uniformsList.push(\"morphTargetInfluences\");\r\n        uniformsList.push(\"morphTargetCount\");\r\n    }\r\n\r\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n        uniformsList.push(\"bakedVertexAnimationSettings\");\r\n        uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n        uniformsList.push(\"bakedVertexAnimationTime\");\r\n        samplersList.push(\"bakedVertexAnimationTexture\");\r\n    }\r\n}\r\n", "import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class that holds the different stencil states of a material\r\n * Usage example: https://playground.babylonjs.com/#CW5PRI#10\r\n */\r\nexport class MaterialStencilState implements IStencilState {\r\n    /**\r\n     * Creates a material stencil state instance\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Resets all the stencil states to default values\r\n     */\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.func = Constants.ALWAYS;\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.opStencilFail = Constants.KEEP;\r\n        this.opDepthFail = Constants.KEEP;\r\n        this.opStencilDepthPass = Constants.REPLACE;\r\n    }\r\n\r\n    private _func: number;\r\n    /**\r\n     * Gets or sets the stencil function\r\n     */\r\n    @serialize()\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        this._func = value;\r\n    }\r\n\r\n    private _funcRef: number;\r\n    /**\r\n     * Gets or sets the stencil function reference\r\n     */\r\n    @serialize()\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        this._funcRef = value;\r\n    }\r\n\r\n    private _funcMask: number;\r\n    /**\r\n     * Gets or sets the stencil function mask\r\n     */\r\n    @serialize()\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        this._funcMask = value;\r\n    }\r\n\r\n    private _opStencilFail: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil test fails\r\n     */\r\n    @serialize()\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        this._opStencilFail = value;\r\n    }\r\n\r\n    private _opDepthFail: number;\r\n    /**\r\n     * Gets or sets the operation when the depth test fails\r\n     */\r\n    @serialize()\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        this._opDepthFail = value;\r\n    }\r\n\r\n    private _opStencilDepthPass: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil+depth test succeeds\r\n     */\r\n    @serialize()\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        this._opStencilDepthPass = value;\r\n    }\r\n\r\n    private _mask: number;\r\n    /**\r\n     * Gets or sets the stencil mask\r\n     */\r\n    @serialize()\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        this._mask = value;\r\n    }\r\n\r\n    private _enabled: boolean;\r\n    /**\r\n     * Enables or disables the stencil test\r\n     */\r\n    @serialize()\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        this._enabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name, useful for serialization or dynamic coding.\r\n     * @returns \"MaterialStencilState\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialStencilState\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param stencilState defines stencil state where to copy the info\r\n     */\r\n    public copyTo(stencilState: MaterialStencilState): void {\r\n        SerializationHelper.Clone(() => stencilState, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this stencil configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a stencil state configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Scene } from \"../scene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\n\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { BindSceneUniformBuffer } from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable, IClipPlanesHolder {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty image processing flag value\r\n     */\r\n    public static readonly ImageProcessingDirtyFlag = Constants.MATERIAL_ImageProcessingDirtyFlag;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _forceGLSL = false;\r\n\r\n    /** @internal */\r\n    public get _supportGlowLayer() {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _glowModeEnabled(value: boolean) {\r\n        // Do nothing here\r\n    }\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._alpha;\r\n        this._alpha = value;\r\n\r\n        // Only call dirty when there is a state change (no alpha / alpha)\r\n        if (oldValue === 1 || value === 1) {\r\n            this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    private _blockDirtyMechanism = false;\r\n\r\n    /**\r\n     * Block the dirty-mechanism for this specific material\r\n     * When set to false after being true the material will be marked as dirty.\r\n     */\r\n    public get blockDirtyMechanism(): boolean {\r\n        return this._blockDirtyMechanism;\r\n    }\r\n\r\n    public set blockDirtyMechanism(value: boolean) {\r\n        if (this._blockDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            this.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows you to modify the material without marking it as dirty after every change.\r\n     * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\r\n     * The callback will pass the material as an argument, so you can make your changes to it.\r\n     * @param callback the callback to be executed that will update the material\r\n     */\r\n    public atomicMaterialsUpdate(callback: (material: this) => void): void {\r\n        this.blockDirtyMechanism = true;\r\n        try {\r\n            callback(this);\r\n        } finally {\r\n            this.blockDirtyMechanism = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: Nullable<number> = null;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize(\"alphaMode\")\r\n    private _alphaMode: number = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |   |\r\n     * | 1 | ALPHA_ADD |   |\r\n     * | 2 | ALPHA_COMBINE |   |\r\n     * | 3 | ALPHA_SUBTRACT |   |\r\n     * | 4 | ALPHA_MULTIPLY |   |\r\n     * | 5 | ALPHA_MAXIMIZED |   |\r\n     * | 6 | ALPHA_ONEONE |   |\r\n     * | 7 | ALPHA_PREMULTIPLIED |   |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\r\n     * | 9 | ALPHA_INTERPOLATE |   |\r\n     * | 10 | ALPHA_SCREENMODE |   |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode === value) {\r\n            return;\r\n        }\r\n        this._alphaMode = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    protected _useLogarithmicDepth: boolean;\r\n\r\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\r\n     */\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n\r\n        if (value && !fragmentDepthSupported) {\r\n            Logger.Warn(\"Logarithmic depth has been requested for a material on a device that doesn't support it.\");\r\n        }\r\n\r\n        this._useLogarithmicDepth = value && fragmentDepthSupported;\r\n\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stores the effects for the material\r\n     */\r\n    public _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @internal */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @internal\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @internal */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @internal */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @internal */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefinesBeforeAttributes: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean, forceGLSL = false) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n        this._forceGLSL = forceGLSL;\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        this._createUniformBuffer();\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createUniformBuffer() {\r\n        const engine = this.getScene().getEngine();\r\n\r\n        this._uniformBuffer?.dispose();\r\n\r\n        if (engine.isWebGPU && !this._forceGLSL) {\r\n            // Switch main UBO to non UBO to connect to leftovers UBO in webgpu\r\n            this._uniformBuffer = new UniformBuffer(engine, undefined, undefined, this.name, true);\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        } else {\r\n            this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, this.name);\r\n        }\r\n\r\n        this._uniformBufferLayoutBuilt = false;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isMaterial() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getEffectiveOrientation(mesh: Mesh): number {\r\n        return this.sideOrientation !== null ? this.sideOrientation : mesh.sideOrientation;\r\n    }\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    protected get _hasTransparencyMode(): boolean {\r\n        return this._transparencyMode != null;\r\n    }\r\n\r\n    protected get _transparencyModeIsBlend(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHABLEND || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    protected get _transparencyModeIsTest(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHATEST || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     * @deprecated Please use needAlphaBlendingForMesh instead\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (mesh.visibility < 1.0) {\r\n            return true;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return mesh.hasVertexAlpha || this.needAlphaBlending();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     * @deprecated Please use needAlphaTestingForMesh instead\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha testing should be turned on for the mesh\r\n     */\r\n    public needAlphaTestingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\r\n     */\r\n    public markDirty(forceMaterialDirty = false): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        drawWrapper._wasPreviouslyReady = false;\r\n                        drawWrapper._wasPreviouslyUsingInstances = null;\r\n                        drawWrapper._forceRebindOnNextCall = forceMaterialDirty;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (forceMaterialDirty) {\r\n            this.markAsDirty(Material.AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        engine.enableEffect(effect ? effect : this._getDrawWrapper());\r\n        engine.setState(\r\n            this.backFaceCulling,\r\n            this.zOffset,\r\n            false,\r\n            reverse,\r\n            this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces,\r\n            this.stencil,\r\n            this.zOffsetUnits\r\n        );\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n        drawWrapper._forceRebindOnNextCall = false;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect defines the effect used to bind the material\r\n     * @param _subMesh defines the subMesh that the material has been bound for\r\n     */\r\n    protected _afterBind(mesh?: AbstractMesh, effect: Nullable<Effect> = null, _subMesh?: SubMesh): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        this._scene.getSceneUniformBuffer().unbindEffect();\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    protected _clonePlugins(targetMaterial: Material, rootUrl: string) {\r\n        const serializationObject: any = {};\r\n\r\n        // Create plugins in targetMaterial in case they don't exist\r\n        this._serializePlugins(serializationObject);\r\n\r\n        Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\r\n\r\n        // Copy the properties of the current plugins to the cloned material's plugins\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                const targetPlugin = targetMaterial.pluginManager!.getPlugin(plugin.name);\r\n                if (targetPlugin) {\r\n                    plugin.copyTo(targetPlugin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result: AbstractMesh[] = [];\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.ImageProcessingDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._ImageProcessingDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        const scene = this.getScene();\r\n        if (scene.blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = scene.meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                const material = subMesh.getMaterial() || (scene._hasDefaultMaterial ? scene.defaultMaterial : null);\r\n                if (material !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._PrePassDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    protected _checkScenePerformancePriority() {\r\n        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n            // re-set the flag when the perf priority changes\r\n            const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\r\n                this.checkReadyOnlyOnce = false;\r\n            });\r\n            // if this material is disposed before the scene is disposed, cleanup the observer\r\n            this.onDisposeObservable.add(() => {\r\n                this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param _forceDisposeEffect kept for backward compat. We reference count the effect now.\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(_forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n\r\n        if (this._eventInfo) {\r\n            this._eventInfo = {} as any;\r\n        }\r\n    }\r\n\r\n    private _disposeMeshResources(mesh: AbstractMesh | undefined) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const geometry = (<Mesh>mesh).geometry;\r\n        const materialForRenderPass = mesh._internalAbstractMeshDataInfo._materialForRenderPass;\r\n        if (this._storeEffectOnSubMeshes) {\r\n            if (mesh.subMeshes && materialForRenderPass) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    const drawWrappers = subMesh._drawWrappers;\r\n                    for (let renderPassIndex = 0; renderPassIndex < drawWrappers.length; renderPassIndex++) {\r\n                        const effect = drawWrappers[renderPassIndex]?.effect;\r\n                        if (!effect) {\r\n                            continue;\r\n                        }\r\n                        const material = materialForRenderPass[renderPassIndex];\r\n                        if (material === this) {\r\n                            geometry?._releaseVertexArrayObject(effect);\r\n                            subMesh._removeDrawWrapper(renderPassIndex, true, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            geometry?._releaseVertexArrayObject(this._drawWrapper.effect);\r\n        }\r\n\r\n        if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n            mesh.material = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        this._serializePlugins(serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    protected _serializePlugins(serializationObject: any) {\r\n        serializationObject.plugins = {};\r\n\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                if (!plugin.doNotSerialize) {\r\n                    serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n\r\n        return material;\r\n    }\r\n\r\n    protected static _ParsePlugins(serializationObject: any, material: Material, scene: Scene, rootUrl: string) {\r\n        if (!serializationObject.plugins) {\r\n            return;\r\n        }\r\n\r\n        for (const pluginClassName in serializationObject.plugins) {\r\n            const pluginData = serializationObject.plugins[pluginClassName];\r\n\r\n            let plugin = material.pluginManager?.getPlugin(pluginData.name);\r\n\r\n            if (!plugin) {\r\n                const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\r\n                if (pluginClassType) {\r\n                    plugin = new pluginClassType(material);\r\n                }\r\n            }\r\n\r\n            plugin?.parse(pluginData, scene, rootUrl);\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKM,IAAO,mBAAP,MAAuB;EAIzB,YACW,IACA,IACA,UAAgB;AAFhB,SAAA,KAAA;AACA,SAAA,KAAA;AACA,SAAA,WAAA;AANJ,SAAA,SAAS;AACT,SAAA,YAAY;EAMhB;;;;ACCD,IAAO,cAAP,MAAO,aAAW;;;;;;;EAiEpB,YAAY,KAA6B,KAA6B,aAAmC;AA7DzF,SAAA,UAAqB,WAAW,GAAG,QAAQ,IAAI;AAI/C,SAAA,SAAkB,QAAQ,KAAI;AAI9B,SAAA,cAAuB,QAAQ,KAAI;AAInC,SAAA,aAAsB,QAAQ,KAAI;AAIlC,SAAA,kBAA2B,QAAQ,KAAI;AAIvC,SAAA,aAAwB,WAAW,GAAG,QAAQ,IAAI;AAIlD,SAAA,eAA0B,WAAW,GAAG,QAAQ,IAAI;AAIpD,SAAA,eAAwB,QAAQ,KAAI;AAIpC,SAAA,eAAwB,QAAQ,KAAI;AAIpC,SAAA,UAAmB,QAAQ,KAAI;AAI/B,SAAA,UAAmB,QAAQ,KAAI;AAWxC,SAAA,oBAA2C;AAE3C,SAAA,mBAA0C;AAS7C,SAAK,YAAY,KAAK,KAAK,WAAW;EAC1C;;;;;;;;EAUO,YAAY,KAA6B,KAA6B,aAAmC;AAC5G,UAAM,OAAO,IAAI,GACb,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI;AACf,UAAM,UAAU,KAAK;AAErB,SAAK,QAAQ,eAAe,MAAM,MAAM,IAAI;AAC5C,SAAK,QAAQ,eAAe,MAAM,MAAM,IAAI;AAC5C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAC1C,YAAQ,CAAC,EAAE,eAAe,MAAM,MAAM,IAAI;AAG1C,QAAI,SAAS,KAAK,KAAK,MAAM,EAAE,aAAa,GAAG;AAC/C,QAAI,cAAc,KAAK,KAAK,UAAU,EAAE,aAAa,GAAG;AAExD,SAAK,eAAe,eAAe,OAAO;AAE1C,SAAK,QAAQ,KAAK,YAAY;EAClC;;;;;;EAOO,MAAM,QAAc;AACvB,UAAM,aAAa,aAAY;AAC/B,UAAM,OAAO,KAAK,QAAQ,cAAc,KAAK,SAAS,WAAW,CAAC,CAAC;AACnE,UAAM,MAAM,KAAK,OAAM;AACvB,SAAK,oBAAoB,GAAG;AAC5B,UAAM,WAAW,MAAM;AACvB,UAAM,YAAY,KAAK,aAAa,WAAW,GAAG;AAElD,UAAM,MAAM,KAAK,OAAO,cAAc,WAAW,WAAW,CAAC,CAAC;AAC9D,UAAM,MAAM,KAAK,OAAO,SAAS,WAAW,WAAW,CAAC,CAAC;AAEzD,SAAK,YAAY,KAAK,KAAK,KAAK,YAAY;AAE5C,WAAO;EACX;;;;;EAMO,iBAAc;AACjB,WAAO,KAAK;EAChB;;;;EAKO,QAAQ,OAA4B;AACvC,UAAM,WAAW,KAAK;AACtB,UAAM,WAAW,KAAK;AACtB,UAAM,aAAa,KAAK;AACxB,UAAM,eAAe,KAAK;AAC1B,UAAM,UAAU,KAAK;AAErB,QAAI,CAAC,MAAM,WAAU,GAAI;AACrB,eAAS,OAAO,OAAO,SAAS;AAChC,eAAS,OAAO,CAAC,OAAO,SAAS;AAEjC,eAAS,QAAQ,GAAG,QAAQ,GAAG,EAAE,OAAO;AACpC,cAAM,IAAI,aAAa,KAAK;AAC5B,gBAAQ,0BAA0B,QAAQ,KAAK,GAAG,OAAO,CAAC;AAC1D,iBAAS,gBAAgB,CAAC;AAC1B,iBAAS,gBAAgB,CAAC;MAC9B;AAGA,eAAS,cAAc,UAAU,KAAK,eAAe,EAAE,aAAa,GAAG;AACvE,eAAS,SAAS,UAAU,KAAK,WAAW,EAAE,aAAa,GAAG;IAClE,OAAO;AACH,eAAS,SAAS,KAAK,OAAO;AAC9B,eAAS,SAAS,KAAK,OAAO;AAC9B,eAAS,QAAQ,GAAG,QAAQ,GAAG,EAAE,OAAO;AACpC,qBAAa,KAAK,EAAE,SAAS,QAAQ,KAAK,CAAC;MAC/C;AAGA,WAAK,gBAAgB,SAAS,KAAK,UAAU;AAC7C,WAAK,YAAY,SAAS,KAAK,MAAM;IACzC;AAEA,YAAQ,eAAe,MAAM,GAAG,GAAG,WAAW,CAAC,CAAC;AAChD,YAAQ,eAAe,MAAM,GAAG,GAAG,WAAW,CAAC,CAAC;AAChD,YAAQ,eAAe,MAAM,GAAG,GAAG,WAAW,CAAC,CAAC;AAEhD,SAAK,eAAe;EACxB;;;;;;EAOO,YAAY,eAA0C;AACzD,WAAO,aAAY,YAAY,KAAK,cAAc,aAAa;EACnE;;;;;;EAOO,sBAAsB,eAA0C;AACnE,WAAO,aAAY,sBAAsB,KAAK,cAAc,aAAa;EAC7E;;;;;;EAOO,gBAAgB,OAA6B;AAChD,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AACjB,UAAM,OAAO,IAAI,GACb,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI;AACf,UAAM,SAAS,MAAM,GACjB,SAAS,MAAM,GACf,SAAS,MAAM;AACnB,UAAM,QAAQ,CAAC;AAEf,QAAI,OAAO,SAAS,SAAS,QAAQ,SAAS,MAAM;AAChD,aAAO;IACX;AAEA,QAAI,OAAO,SAAS,SAAS,QAAQ,SAAS,MAAM;AAChD,aAAO;IACX;AAEA,QAAI,OAAO,SAAS,SAAS,QAAQ,SAAS,MAAM;AAChD,aAAO;IACX;AAEA,WAAO;EACX;;;;;;EAOO,iBAAiB,QAAqC;AACzD,WAAO,aAAY,iBAAiB,KAAK,cAAc,KAAK,cAAc,OAAO,aAAa,OAAO,WAAW;EACpH;;;;;;;EAQO,iBAAiB,KAA6B,KAA2B;AAC5E,UAAM,QAAQ,KAAK;AACnB,UAAM,QAAQ,KAAK;AACnB,UAAM,SAAS,MAAM,GACjB,SAAS,MAAM,GACf,SAAS,MAAM,GACf,SAAS,MAAM,GACf,SAAS,MAAM,GACf,SAAS,MAAM;AACnB,UAAM,OAAO,IAAI,GACb,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI,GACX,OAAO,IAAI;AACf,QAAI,SAAS,QAAQ,SAAS,MAAM;AAChC,aAAO;IACX;AAEA,QAAI,SAAS,QAAQ,SAAS,MAAM;AAChC,aAAO;IACX;AAEA,QAAI,SAAS,QAAQ,SAAS,MAAM;AAChC,aAAO;IACX;AAEA,WAAO;EACX;;;;EAKO,UAAO;AAnSlB;AAoSQ,eAAK,sBAAL,mBAAwB;AACxB,eAAK,qBAAL,mBAAuB;EAC3B;;;;;;;;EAUO,OAAO,WAAW,MAAkC,MAAgC;AACvF,WAAO,KAAK,iBAAiB,KAAK,cAAc,KAAK,YAAY;EACrE;;;;;;;;;EAUO,OAAO,iBAAiB,UAAkC,UAAkC,cAAsC,cAAoB;AACzJ,UAAM,SAAS,aAAY,YAAY,CAAC;AACxC,YAAQ,WAAW,cAAc,UAAU,UAAU,MAAM;AAC3D,UAAM,MAAM,QAAQ,gBAAgB,cAAc,MAAM;AACxD,WAAO,OAAO,eAAe;EACjC;;;;;;;EAQO,OAAO,sBAAsB,iBAAgD,eAA0C;AAC1H,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACxB,YAAM,eAAe,cAAc,CAAC;AACpC,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACxB,YAAI,aAAa,cAAc,gBAAgB,CAAC,CAAC,IAAI,GAAG;AACpD,iBAAO;QACX;MACJ;IACJ;AACA,WAAO;EACX;;;;;;;EAQO,OAAO,YAAY,iBAAgD,eAA0C;AAChH,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACxB,UAAI,iBAAiB;AACrB,YAAM,eAAe,cAAc,CAAC;AACpC,eAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AACxB,YAAI,aAAa,cAAc,gBAAgB,CAAC,CAAC,KAAK,GAAG;AACrD,2BAAiB;AACjB;QACJ;MACJ;AACA,UAAI,gBAAgB;AAChB,eAAO;MACX;IACJ;AACA,WAAO;EACX;;AA9SwB,YAAA,cAAc,WAAW,GAAG,QAAQ,IAAI;;;ACrD9D,IAAO,iBAAP,MAAO,gBAAc;;;;;;;EAmCvB,YAAY,KAA6B,KAA6B,aAAmC;AA/BzF,SAAA,SAAS,QAAQ,KAAI;AAQrB,SAAA,cAAc,QAAQ,KAAI;AAQ1B,SAAA,UAAU,QAAQ,KAAI;AAItB,SAAA,UAAU,QAAQ,KAAI;AAYlC,SAAK,YAAY,KAAK,KAAK,WAAW;EAC1C;;;;;;;EAQO,YAAY,KAA6B,KAA6B,aAAmC;AAC5G,SAAK,QAAQ,SAAS,GAAG;AACzB,SAAK,QAAQ,SAAS,GAAG;AAEzB,UAAM,WAAW,QAAQ,SAAS,KAAK,GAAG;AAE1C,QAAI,SAAS,KAAK,KAAK,MAAM,EAAE,aAAa,GAAG;AAC/C,SAAK,SAAS,WAAW;AAEzB,SAAK,QAAQ,eAAe,OAAO,gBAAgB;EACvD;;;;;;EAOO,MAAM,QAAc;AACvB,UAAM,YAAY,KAAK,SAAS;AAChC,UAAM,aAAa,gBAAe;AAClC,UAAM,mBAAmB,WAAW,CAAC,EAAE,OAAO,SAAS;AACvD,UAAM,MAAM,KAAK,OAAO,cAAc,kBAAkB,WAAW,CAAC,CAAC;AACrE,UAAM,MAAM,KAAK,OAAO,SAAS,kBAAkB,WAAW,CAAC,CAAC;AAEhE,SAAK,YAAY,KAAK,KAAK,KAAK,YAAY;AAE5C,WAAO;EACX;;;;;EAMO,iBAAc;AACjB,WAAO,KAAK;EAChB;;;;;EAMO,QAAQ,aAAkC;AAC7C,QAAI,CAAC,YAAY,WAAU,GAAI;AAC3B,cAAQ,0BAA0B,KAAK,QAAQ,aAAa,KAAK,WAAW;AAC5E,YAAM,aAAa,gBAAe,YAAY,CAAC;AAC/C,cAAQ,+BAA+B,GAAK,GAAK,GAAK,aAAa,UAAU;AAC7E,WAAK,cAAc,KAAK,IAAI,KAAK,IAAI,WAAW,CAAC,GAAG,KAAK,IAAI,WAAW,CAAC,GAAG,KAAK,IAAI,WAAW,CAAC,CAAC,IAAI,KAAK;IAC/G,OAAO;AACH,WAAK,YAAY,SAAS,KAAK,MAAM;AACrC,WAAK,cAAc,KAAK;IAC5B;EACJ;;;;;;EAOO,YAAY,eAA0C;AACzD,UAAM,SAAS,KAAK;AACpB,UAAM,SAAS,KAAK;AACpB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAI,cAAc,CAAC,EAAE,cAAc,MAAM,KAAK,CAAC,QAAQ;AACnD,eAAO;MACX;IACJ;AACA,WAAO;EACX;;;;;;;EAQO,kBAAkB,eAA0C;AAC/D,UAAM,SAAS,KAAK;AACpB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAI,cAAc,CAAC,EAAE,cAAc,MAAM,IAAI,GAAG;AAC5C,eAAO;MACX;IACJ;AACA,WAAO;EACX;;;;;;EAOO,gBAAgB,OAA6B;AAChD,UAAM,iBAAiB,QAAQ,gBAAgB,KAAK,aAAa,KAAK;AACtE,QAAI,KAAK,cAAc,KAAK,cAAc,gBAAgB;AACtD,aAAO;IACX;AAEA,WAAO;EACX;;;;;;;;EASO,OAAO,WAAW,SAAwC,SAAsC;AACnG,UAAM,iBAAiB,QAAQ,gBAAgB,QAAQ,aAAa,QAAQ,WAAW;AACvF,UAAM,YAAY,QAAQ,cAAc,QAAQ;AAEhD,QAAI,YAAY,YAAY,gBAAgB;AACxC,aAAO;IACX;AAEA,WAAO;EACX;;;;;;;;EASO,OAAO,0BAA0B,QAAgC,QAAgB,QAA8B;AAClH,SAAK,YAAY,CAAC,EAAE,SAAS,MAAM;AACnC,SAAK,YAAY,CAAC,EAAE,eAAe,GAAG,GAAG,MAAM;AAC/C,SAAK,YAAY,CAAC,EAAE,SAAS,MAAM;AACnC,SAAK,YAAY,CAAC,EAAE,WAAW,KAAK,YAAY,CAAC,CAAC;AAClD,SAAK,YAAY,CAAC,EAAE,gBAAgB,KAAK,YAAY,CAAC,CAAC;AAEvD,UAAM,SAAS,IAAI,gBAAe,KAAK,YAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAAC;AAE1E,QAAI,QAAQ;AACR,aAAO,eAAe;IAC1B,OAAO;AACH,aAAO,eAAe,OAAO,SAAQ;IACzC;AAEA,WAAO;EACX;;AA9JwB,eAAA,cAAc,WAAW,GAAG,QAAQ,IAAI;;;ACvBpE,IAAM,WAAW,EAAE,KAAK,GAAG,KAAK,EAAC;AACjC,IAAM,WAAW,EAAE,KAAK,GAAG,KAAK,EAAC;AACjC,IAAM,oBAAoB,CAAC,MAA8B,KAAiC,WAAwC;AAC9H,QAAM,IAAI,QAAQ,IAAI,IAAI,aAAa,IAAI;AAE3C,QAAM,KAAK,KAAK,IAAI,QAAQ,IAAI,IAAI,WAAW,CAAC,GAAG,IAAI,CAAC,IAAI,IAAI,WAAW;AAC3E,QAAM,KAAK,KAAK,IAAI,QAAQ,IAAI,IAAI,WAAW,CAAC,GAAG,IAAI,CAAC,IAAI,IAAI,WAAW;AAC3E,QAAM,KAAK,KAAK,IAAI,QAAQ,IAAI,IAAI,WAAW,CAAC,GAAG,IAAI,CAAC,IAAI,IAAI,WAAW;AAE3E,QAAM,IAAI,KAAK,KAAK;AACpB,SAAO,MAAM,IAAI;AACjB,SAAO,MAAM,IAAI;AACrB;AAEA,IAAM,cAAc,CAAC,MAA8B,MAAkC,SAA6C;AAC9H,oBAAkB,MAAM,MAAM,QAAQ;AACtC,oBAAkB,MAAM,MAAM,QAAQ;AACtC,SAAO,EAAE,SAAS,MAAM,SAAS,OAAO,SAAS,MAAM,SAAS;AACpE;AAyBM,IAAO,eAAP,MAAO,cAAY;;;;;;;EAoBrB,YAAY,SAAiC,SAAiC,aAAmC;AAVzG,SAAA,YAAY;AAWhB,SAAK,cAAc,IAAI,YAAY,SAAS,SAAS,WAAW;AAChE,SAAK,iBAAiB,IAAI,eAAe,SAAS,SAAS,WAAW;EAC1E;;;;;;;EAQO,YAAY,KAA6B,KAA6B,aAAmC;AAC5G,SAAK,YAAY,YAAY,KAAK,KAAK,WAAW;AAClD,SAAK,eAAe,YAAY,KAAK,KAAK,WAAW;EACzD;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,YAAY;EAC5B;;;;EAKA,IAAW,UAAO;AACd,WAAO,KAAK,YAAY;EAC5B;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;EAEA,IAAW,SAAS,OAAc;AAC9B,SAAK,YAAY;EACrB;;;;;;EAOO,OAAO,OAA4B;AACtC,QAAI,KAAK,WAAW;AAChB;IACJ;AACA,SAAK,YAAY,QAAQ,KAAK;AAC9B,SAAK,eAAe,QAAQ,KAAK;EACrC;;;;;;;EAQO,SAAS,QAAgC,QAA8B;AAC1E,UAAM,UAAU,cAAa,YAAY,CAAC,EAAE,SAAS,MAAM,EAAE,gBAAgB,MAAM;AACnF,UAAM,UAAU,cAAa,YAAY,CAAC,EAAE,SAAS,MAAM,EAAE,WAAW,MAAM;AAE9E,SAAK,YAAY,YAAY,SAAS,SAAS,KAAK,YAAY,eAAc,CAAE;AAChF,SAAK,eAAe,YAAY,SAAS,SAAS,KAAK,YAAY,eAAc,CAAE;AAEnF,WAAO;EACX;;;;;;EAOO,YAAY,OAAc;AAC7B,UAAM,UAAU,QAAQ,SAAS,KAAK,SAAS,KAAK;AACpD,UAAM,UAAU,QAAQ,SAAS,KAAK,SAAS,KAAK;AACpD,SAAK,YAAY,SAAS,SAAS,KAAK,YAAY,eAAc,CAAE;AAEpE,WAAO;EACX;;;;;;EAOO,wBAAwB,eAA2B;AACtD,UAAM,OAAO,WAAW,OAAO,CAAC;AAChC,SAAK,YAAY,eAAc,EAAG,YAAY,IAAI;AAElD,UAAM,IAAI,WAAW,QAAQ,CAAC;AAE9B,YAAQ,0BAA0B,cAAc,YAAY,cAAc,MAAM,CAAC;AACjF,SAAK,YAAY,CAAC;AAElB,YAAQ,0BAA0B,cAAc,YAAY,cAAc,MAAM,CAAC;AACjF,SAAK,YAAY,CAAC;AAElB,WAAO;EACX;;;;;;EAOO,MAAM,QAAc;AACvB,SAAK,YAAY,MAAM,MAAM;AAC7B,SAAK,eAAe,MAAM,MAAM;AAEhC,WAAO;EACX;;;;;;;;;;;;EAaO,YAAY,eAA4C,WAAmB,GAAA;AAC9E,UAAM,gBACF,aAAa,KAAA,aAAU;AAC3B,QAAI,eAAe;AACf,UAAI,KAAK,eAAe,kBAAkB,aAAa,GAAG;AACtD,eAAO;MACX;IACJ;AAEA,QAAI,CAAC,KAAK,eAAe,YAAY,aAAa,GAAG;AACjD,aAAO;IACX;AAEA,UAAM,kBACF,aAAa,KAAA,aAAU;AAC3B,QAAI,iBAAiB;AACjB,aAAO;IACX;AAEA,WAAO,KAAK,YAAY,YAAY,aAAa;EACrD;;;;EAKA,IAAW,iBAAc;AACrB,UAAM,cAAc,KAAK;AACzB,UAAM,OAAO,YAAY,aAAa,cAAc,YAAY,cAAc,cAAa,YAAY,CAAC,CAAC;AACzG,WAAO,KAAK,OAAM;EACtB;;;;;;;EAQO,sBAAsB,eAA0C;AACnE,WAAO,KAAK,YAAY,sBAAsB,aAAa;EAC/D;;;;EAIO,gBAAgB,UAAkB;AACrC,WAAO,SAAS,gBAAgB,KAAK,eAAe,aAAa,KAAK,eAAe,aAAa,KAAK,YAAY,cAAc,KAAK,YAAY,YAAY;EAClK;;;;;;;EAQO,gBAAgB,OAA6B;AAChD,QAAI,CAAC,KAAK,eAAe,aAAa;AAClC,aAAO;IACX;AAEA,QAAI,CAAC,KAAK,eAAe,gBAAgB,KAAK,GAAG;AAC7C,aAAO;IACX;AAEA,QAAI,CAAC,KAAK,YAAY,gBAAgB,KAAK,GAAG;AAC1C,aAAO;IACX;AAEA,WAAO;EACX;;;;;;;;EASO,WAAW,cAA2C,SAAgB;AACzE,QAAI,CAAC,eAAe,WAAW,KAAK,gBAAgB,aAAa,cAAc,GAAG;AAC9E,aAAO;IACX;AAEA,QAAI,CAAC,YAAY,WAAW,KAAK,aAAa,aAAa,WAAW,GAAG;AACrE,aAAO;IACX;AAEA,QAAI,CAAC,SAAS;AACV,aAAO;IACX;AAEA,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,aAAa;AAE1B,QAAI,CAAC,YAAY,KAAK,WAAW,CAAC,GAAG,MAAM,IAAI,GAAG;AAC9C,aAAO;IACX;AACA,QAAI,CAAC,YAAY,KAAK,WAAW,CAAC,GAAG,MAAM,IAAI,GAAG;AAC9C,aAAO;IACX;AACA,QAAI,CAAC,YAAY,KAAK,WAAW,CAAC,GAAG,MAAM,IAAI,GAAG;AAC9C,aAAO;IACX;AACA,QAAI,CAAC,YAAY,KAAK,WAAW,CAAC,GAAG,MAAM,IAAI,GAAG;AAC9C,aAAO;IACX;AACA,QAAI,CAAC,YAAY,KAAK,WAAW,CAAC,GAAG,MAAM,IAAI,GAAG;AAC9C,aAAO;IACX;AACA,QAAI,CAAC,YAAY,KAAK,WAAW,CAAC,GAAG,MAAM,IAAI,GAAG;AAC9C,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AACA,QAAI,CAAC,YAAY,QAAQ,MAAM,KAAK,WAAW,CAAC,GAAG,KAAK,WAAW,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG;AACjF,aAAO;IACX;AAEA,WAAO;EACX;;AAjRwB,aAAA,cAAc,WAAW,GAAG,QAAQ,IAAI;;;AC7DpE,IAAM,cAAN,MAAiB;EAGN,OAAO,wBAAwB,WAAuB,SAAuB,YAAoB,YAAoB,SAAkB,SAAgB;AAC1J,aAAS,QAAQ,YAAY,QAAQ,aAAa,YAAY,SAAS;AACnE,YAAM,SAAS,QAAQ,KAAK,IAAI;AAChC,YAAM,IAAI,UAAU,MAAM;AAC1B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,cAAQ,0BAA0B,GAAG,GAAG,CAAC;AACzC,cAAQ,0BAA0B,GAAG,GAAG,CAAC;IAC7C;EACJ;EAIO,OAAO,iBAAiB,WAAuB,OAAe,OAAe,QAAgB,SAAkB,SAAgB;AAClI,aAAS,QAAQ,OAAO,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,OAAO,SAAS,UAAU,QAAQ;AAC/F,YAAM,IAAI,UAAU,MAAM;AAC1B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,YAAM,IAAI,UAAU,SAAS,CAAC;AAC9B,cAAQ,0BAA0B,GAAG,GAAG,CAAC;AACzC,cAAQ,0BAA0B,GAAG,GAAG,CAAC;IAC7C;EACJ;;AArBc,WAAA;EAFb,eAAe,OAAO,IAAI,CAAC,WAAW,OAAO,MAA8D,CAAC,MAAM,QAAQ,SAAS,KAAK,CAAC,MAAM,QAAQ,OAAO,CAAC;;;AAelJ,WAAA;EAFb,eAAe,OAAO,IAAI,CAAC,SAAS,MAAuD,CAAC,MAAM,QAAQ,SAAS,CAAC;;;AAsBnH,SAAU,wBACZ,WACA,SACA,YACA,YACA,OAA0B,MAAI;AAE9B,QAAM,UAAU,IAAI,QAAQ,OAAO,WAAW,OAAO,WAAW,OAAO,SAAS;AAChF,QAAM,UAAU,IAAI,QAAQ,CAAC,OAAO,WAAW,CAAC,OAAO,WAAW,CAAC,OAAO,SAAS;AAEnF,cAAY,wBAAwB,WAAW,SAAS,YAAY,YAAY,SAAS,OAAO;AAEhG,MAAI,MAAM;AACN,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;EAC3C;AAEA,SAAO;IACH;IACA;;AAER;AAWM,SAAU,iBAAiB,WAAuB,OAAe,OAAe,OAA0B,MAAM,QAAe;AACjI,QAAM,UAAU,IAAI,QAAQ,OAAO,WAAW,OAAO,WAAW,OAAO,SAAS;AAChF,QAAM,UAAU,IAAI,QAAQ,CAAC,OAAO,WAAW,CAAC,OAAO,WAAW,CAAC,OAAO,SAAS;AAEnF,MAAI,CAAC,QAAQ;AACT,aAAS;EACb;AAEA,cAAY,iBAAiB,WAAW,OAAO,OAAO,QAAQ,SAAS,OAAO;AAE9E,MAAI,MAAM;AACN,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;AACvC,YAAQ,KAAK,QAAQ,IAAI,KAAK,IAAI,KAAK;EAC3C;AAEA,SAAO;IACH;IACA;;AAER;;;AC1EM,IAAO,UAAP,MAAO,SAAO;;;;EAShB,IAAW,kBAAe;AAlC9B;AAmCQ,WAAO,KAAK,2BAA4B,KAAK,yBAAyB,WAA+B,UAAK,gBAAe,MAApB,mBAAwB;EACjI;;;;EAKA,IAAW,gBAAgB,SAAkC;AACzD,UAAM,cAAc,KAAK,4BAA4B,KAAK,gBAAgB,QAAW,IAAI;AACzF,gBAAY,UAAU;EAC1B;;;;EAKO,gBAAgB,QAAiB,sBAAsB,OAAK;AAC/D,aAAS,UAAU,KAAK,QAAQ;AAChC,QAAI,cAAc,KAAK,cAAc,MAAM;AAC3C,QAAI,CAAC,eAAe,qBAAqB;AACrC,WAAK,cAAc,MAAM,IAAI,cAAc,IAAI,YAAY,KAAK,MAAM,SAAQ,EAAG,UAAS,CAAE;IAChG;AACA,WAAO;EACX;;;;EAKO,mBAAmB,QAAgB,iBAAiB,MAAM,YAAY,OAAK;AA7DtF;AA8DQ,QAAI,gBAAgB;AAChB,iBAAK,cAAc,MAAM,MAAzB,mBAA4B,QAAQ;IACxC;AACA,SAAK,cAAc,MAAM,IAAI;EACjC;;;;EAKA,IAAW,SAAM;AAvErB;AAwEQ,WAAO,KAAK,2BAA2B,KAAK,yBAAyB,WAAU,UAAK,gBAAe,MAApB,mBAAwB,WAAU;EACrH;;EAGA,IAAW,eAAY;AACnB,WAAO,KAAK,4BAA4B,KAAK,gBAAgB,QAAW,IAAI;EAChF;;EAGA,IAAW,uBAAoB;AAC3B,WAAO,KAAK;EAChB;;;;EAKO,4BAA4B,SAA8B;AAC7D,SAAK,2BAA2B;EACpC;;;;;;;;EASO,UAAU,QAA0B,UAA8C,MAAM,iBAAoC,eAAe,MAAI;AAClJ,UAAM,cAAc,KAAK;AACzB,gBAAY,UAAU,QAAQ,SAAS,YAAY;AACnD,QAAI,oBAAoB,QAAW;AAC/B,kBAAY,kBAAkB;IAClC;AACA,QAAI,CAAC,QAAQ;AACT,kBAAY,UAAU;AACtB,kBAAY,kBAAkB;IAClC;EACJ;;;;;;EAOO,eAAe,QAAiB,YAAY,OAAK;AACpD,QAAI,KAAK,eAAe;AACpB,UAAI,WAAW,QAAW;AACtB,aAAK,mBAAmB,QAAQ,MAAM,SAAS;AAC/C;MACJ,OAAO;AACH,mBAAW,eAAe,KAAK,eAAe;AAC1C,qDAAa,QAAQ;QACzB;MACJ;IACJ;AACA,SAAK,gBAAgB,CAAA;EACzB;;;;;;;;;;;;;EAwCO,OAAO,UACV,eACA,eACA,eACA,YACA,YACA,MACA,eACA,oBAA6B,MAAI;AAEjC,WAAO,IAAI,SAAQ,eAAe,eAAe,eAAe,YAAY,YAAY,MAAM,eAAe,iBAAiB;EAClI;;;;;;;;;;;;;EAcA,YAEW,eAEA,eAEA,eAEA,YAEA,YACP,MACA,eACA,oBAA6B,MAC7B,YAAY,MAAI;AAZT,SAAA,gBAAA;AAEA,SAAA,gBAAA;AAEA,SAAA,gBAAA;AAEA,SAAA,aAAA;AAEA,SAAA,aAAA;AA9KH,SAAA,2BAAkD;AAsGnD,SAAA,mBAA2B;AAI1B,SAAA,oBAA0C;AAE3C,SAAA,6BAAkD;AAIlD,SAAA,+BAAiD;AAEjD,SAAA,iBAAiB;AAGjB,SAAA,YAAY;AAEZ,SAAA,cAAsB;AAEtB,SAAA,oBAA4B;AAI3B,SAAA,mBAAuC;AAuD3C,SAAK,QAAQ;AACb,SAAK,iBAAiB,iBAAuB;AAC7C,QAAI,WAAW;AACX,WAAK,UAAU,KAAK,IAAI;IAC5B;AAEA,SAAK,UAAU,KAAK,MAAM,SAAQ,EAAG,UAAS;AAC9C,SAAK,eAAc;AACnB,SAAK,kBAAkB,CAAA;AAEvB,SAAK,MAAM,KAAK,UAAU,SAAS;AAEnC,QAAI,mBAAmB;AACnB,WAAK,oBAAmB;AACxB,WAAK,mBAAmB,IAAI;IAChC;EACJ;;;;;;EAOA,IAAW,WAAQ;AACf,WAAO,KAAK,kBAAkB,KAAK,KAAK,kBAAkB,KAAK,MAAM,iBAAgB,KAAM,KAAK,eAAe,KAAK,KAAK,eAAe,KAAK,MAAM,gBAAe;EACtK;;;;;EAMO,kBAAe;AAClB,QAAI,KAAK,YAAY,KAAK,MAAM,kBAAkB;AAC9C,aAAO,KAAK,MAAM,gBAAe;IACrC;AAEA,WAAO,KAAK;EAChB;;;;;;EAOO,gBAAgB,cAA0B;AAC7C,SAAK,gBAAgB;AACrB,WAAO;EACX;;;;;EAMO,UAAO;AACV,WAAO,KAAK;EAChB;;;;;EAMO,mBAAgB;AACnB,WAAO,KAAK;EAChB;;;;;EAMO,qBAAkB;AACrB,WAAO,KAAK,MAAM,8BAA8B,oBAAoB,KAAK,QAAQ;EACrF;;;;;EAMO,mBAAgB;AACnB,UAAM,kBAAkB,KAAK,MAAM,8BAA8B,oBAAoB,KAAK,QAAQ;AAElG,WAAO,kBAAkB,kBAAkB,KAAK;EACpD;;;;;;EAOO,YAAY,qBAAqB,MAAI;AACxC,UAAM,eAAe,KAAK,eAAe,yBAAyB,KAAK,QAAQ,mBAAmB,KAAK,KAAK,eAAe;AAE3H,QAAI,CAAC,cAAc;AACf,aAAO,sBAAsB,KAAK,MAAM,SAAQ,EAAG,sBAAsB,KAAK,MAAM,SAAQ,EAAG,kBAAkB;IACrH,WAAW,KAAK,iBAAiB,YAAY,GAAG;AAC5C,YAAM,oBAAoB,aAAa,eAAe,KAAK,aAAa;AAExE,UAAI,KAAK,qBAAqB,mBAAmB;AAC7C,aAAK,mBAAmB;AACxB,aAAK,eAAc;MACvB;AAEA,aAAO;IACX;AAEA,WAAO;EACX;EAEQ,iBAAiB,UAAkB;AACvC,WAAQ,SAA2B,mBAAmB;EAC1D;;;;;;;EASO,oBAAoB,OAA6B,MAAI;AACxD,SAAK,6BAA6B;AAElC,QAAI,KAAK,YAAY,CAAC,KAAK,kBAAkB,CAAC,KAAK,eAAe,UAAU;AACxE,aAAO;IACX;AAEA,QAAI,CAAC,MAAM;AACP,aAAO,KAAK,eAAe,gBAAgB,aAAa,YAAY;IACxE;AAEA,QAAI,CAAC,MAAM;AACP,WAAK,gBAAgB,KAAK,MAAM,gBAAe;AAC/C,aAAO;IACX;AAEA,UAAM,UAAwB,KAAK,eAAe,WAAU;AAC5D,QAAI;AAGJ,QAAI,KAAK,eAAe,KAAK,KAAK,eAAe,QAAQ,QAAQ;AAC7D,YAAM,eAAe,KAAK,eAAe,gBAAe;AAGxD,eAAS,EAAE,SAAS,aAAa,QAAQ,MAAK,GAAI,SAAS,aAAa,QAAQ,MAAK,EAAE;IAC3F,OAAO;AACH,eAAS,wBAAwB,MAAM,SAAS,KAAK,YAAY,KAAK,YAAY,KAAK,eAAe,SAAS,YAAY;IAC/H;AAEA,QAAI,KAAK,eAAe;AACpB,WAAK,cAAc,YAAY,OAAO,SAAS,OAAO,OAAO;IACjE,OAAO;AACH,WAAK,gBAAgB,IAAI,aAAa,OAAO,SAAS,OAAO,OAAO;IACxE;AACA,WAAO;EACX;;;;EAKO,gBAAgB,UAAkB;AACrC,UAAM,eAAe,KAAK,gBAAe;AAEzC,WAAO,aAAa,gBAAgB,QAAQ;EAChD;;;;;;EAOO,mBAAmB,OAA4B;AAClD,QAAI,eAAe,KAAK,gBAAe;AAEvC,QAAI,CAAC,cAAc;AACf,WAAK,oBAAmB;AACxB,qBAAe,KAAK,gBAAe;IACvC;AACA,QAAI,cAAc;AACC,mBAAc,OAAO,KAAK;IAC7C;AACA,WAAO;EACX;;;;;;EAOO,YAAY,eAAsB;AACrC,UAAM,eAAe,KAAK,gBAAe;AAEzC,QAAI,CAAC,cAAc;AACf,aAAO;IACX;AACA,WAAO,aAAa,YAAY,eAAe,KAAK,MAAM,eAAe;EAC7E;;;;;;EAOO,sBAAsB,eAAsB;AAC/C,UAAM,eAAe,KAAK,gBAAe;AAEzC,QAAI,CAAC,cAAc;AACf,aAAO;IACX;AACA,WAAO,aAAa,sBAAsB,aAAa;EAC3D;;;;;;EAOO,OAAO,iBAAwB;AAClC,SAAK,eAAe,OAAO,MAAM,iBAAiB,KAAK,MAAM,8BAA8B,oBAAoB,KAAK,QAAQ,MAAS;AACrI,WAAO;EACX;;;;EAKO,qBAAqB,SAAuB,QAAsB;AACrE,QAAI,CAAC,KAAK,mBAAmB;AACzB,YAAM,qBAAqB,KAAK,MAAM,KAAK,aAAa,CAAC,IAAI;AAC7D,YAAM,kBAAkB,KAAK,gBAAgB,KAAK,gBAAgB;AAClE,YAAM,eAAe,kBAAkB,IAAI,YAAY,kBAAkB,IAAI,IAAI,YAAY,kBAAkB;AAE/G,UAAI,SAAS;AACb,UAAI,QAAQ,WAAW,GAAG;AAEtB,iBAAS,QAAQ,KAAK,YAAY,QAAQ,KAAK,aAAa,KAAK,YAAY,SAAS,GAAG;AACrF,uBAAa,QAAQ,IAAI;AACzB,uBAAa,QAAQ,IAAI,QAAQ;AACjC,uBAAa,QAAQ,IAAI,QAAQ;AACjC,uBAAa,QAAQ,IAAI,QAAQ;AACjC,uBAAa,QAAQ,IAAI,QAAQ;AACjC,uBAAa,QAAQ,IAAI;QAC7B;MACJ,OAAO;AACH,iBAAS,QAAQ,KAAK,YAAY,QAAQ,KAAK,aAAa,KAAK,YAAY,SAAS,GAAG;AACrF,uBAAa,QAAQ,IAAI,QAAQ,KAAK;AACtC,uBAAa,QAAQ,IAAI,QAAQ,QAAQ,CAAC;AAC1C,uBAAa,QAAQ,IAAI,QAAQ,QAAQ,CAAC;AAC1C,uBAAa,QAAQ,IAAI,QAAQ,QAAQ,CAAC;AAC1C,uBAAa,QAAQ,IAAI,QAAQ,QAAQ,CAAC;AAC1C,uBAAa,QAAQ,IAAI,QAAQ,KAAK;QAC1C;MACJ;AAEA,WAAK,oBAAoB,OAAO,kBAAkB,YAAY;AAC9D,WAAK,mBAAmB,aAAa;IACzC;AACA,WAAO,KAAK;EAChB;;;;;;EAOO,cAAc,KAAQ;AACzB,UAAM,eAAe,KAAK,gBAAe;AAEzC,QAAI,CAAC,cAAc;AACf,aAAO;IACX;AACA,WAAO,IAAI,cAAc,aAAa,WAAW;EACrD;;;;;;;;;;EAWO,WAAW,KAAU,WAAsB,SAAuB,WAAqB,mBAA4C;AACtI,UAAM,WAAW,KAAK,YAAW;AACjC,QAAI,CAAC,UAAU;AACX,aAAO;IACX;AACA,QAAI,OAAO;AACX,QAAI,eAAe;AAEnB,YAAQ,SAAS,UAAU;MACvB,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACD,eAAO;MACX,KAAK;AACD,eAAO;AACP,uBAAe;AACf;MACJ;AACI;IACR;AAGA,QAAI,SAAS,aAAa,GAAA;AAEtB,UAAI,CAAC,QAAQ,QAAQ;AACjB,eAAO,KAAK,yBAAyB,KAAK,WAAW,SAAU,KAAK,MAAc,uBAAuB,SAAS;MACtH;AACA,aAAO,KAAK,gBAAgB,KAAK,WAAW,SAAU,KAAK,MAAc,uBAAuB,SAAS;IAC7G,OAAO;AAEH,UAAI,CAAC,QAAQ,UAAU,KAAK,MAAM,YAAY;AAC1C,eAAO,KAAK,6BAA6B,KAAK,WAAW,SAAS,WAAW,iBAAiB;MAClG;AAEA,aAAO,KAAK,oBAAoB,KAAK,WAAW,SAAS,MAAM,cAAc,WAAW,iBAAiB;IAC7G;EACJ;;;;EAKQ,gBAAgB,KAAU,WAAsB,SAAuB,uBAA+B,WAAmB;AAC7H,QAAI,gBAA4C;AAGhD,aAAS,QAAQ,KAAK,YAAY,QAAQ,KAAK,aAAa,KAAK,YAAY,SAAS,GAAG;AACrF,YAAM,KAAK,UAAU,QAAQ,KAAK,CAAC;AACnC,YAAM,KAAK,UAAU,QAAQ,QAAQ,CAAC,CAAC;AAEvC,YAAM,SAAS,IAAI,oBAAoB,IAAI,IAAI,qBAAqB;AACpE,UAAI,SAAS,GAAG;AACZ;MACJ;AAEA,UAAI,aAAa,CAAC,iBAAiB,SAAS,cAAc,UAAU;AAChE,wBAAgB,IAAI,iBAAiB,MAAM,MAAM,MAAM;AACvD,sBAAc,SAAS,QAAQ;AAC/B,YAAI,WAAW;AACX;QACJ;MACJ;IACJ;AACA,WAAO;EACX;;;;EAKQ,yBAAyB,KAAU,WAAsB,SAAuB,uBAA+B,WAAmB;AACtI,QAAI,gBAA4C;AAGhD,aAAS,QAAQ,KAAK,eAAe,QAAQ,KAAK,gBAAgB,KAAK,eAAe,SAAS,GAAG;AAC9F,YAAM,KAAK,UAAU,KAAK;AAC1B,YAAM,KAAK,UAAU,QAAQ,CAAC;AAE9B,YAAM,SAAS,IAAI,oBAAoB,IAAI,IAAI,qBAAqB;AACpE,UAAI,SAAS,GAAG;AACZ;MACJ;AAEA,UAAI,aAAa,CAAC,iBAAiB,SAAS,cAAc,UAAU;AAChE,wBAAgB,IAAI,iBAAiB,MAAM,MAAM,MAAM;AACvD,sBAAc,SAAS,QAAQ;AAC/B,YAAI,WAAW;AACX;QACJ;MACJ;IACJ;AAEA,WAAO;EACX;;;;EAKQ,oBACJ,KACA,WACA,SACA,MACA,cACA,WACA,mBAA4C;AAE5C,QAAI,gBAA4C;AAGhD,QAAI,SAAS;AACb,aAAS,QAAQ,KAAK,YAAY,QAAQ,KAAK,aAAa,KAAK,cAAc,IAAI,OAAO,SAAS,MAAM;AACrG;AACA,YAAM,SAAS,QAAQ,KAAK;AAC5B,YAAM,SAAS,QAAQ,QAAQ,CAAC;AAChC,YAAM,SAAS,QAAQ,QAAQ,CAAC;AAEhC,UAAI,gBAAgB,WAAW,YAAY;AACvC,iBAAS;AACT;MACJ;AAEA,YAAM,KAAK,UAAU,MAAM;AAC3B,YAAM,KAAK,UAAU,MAAM;AAC3B,YAAM,KAAK,UAAU,MAAM;AAG3B,UAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI;AACnB;MACJ;AAEA,UAAI,qBAAqB,CAAC,kBAAkB,IAAI,IAAI,IAAI,KAAK,QAAQ,QAAQ,MAAM,GAAG;AAClF;MACJ;AAEA,YAAM,uBAAuB,IAAI,mBAAmB,IAAI,IAAI,EAAE;AAE9D,UAAI,sBAAsB;AACtB,YAAI,qBAAqB,WAAW,GAAG;AACnC;QACJ;AAEA,YAAI,aAAa,CAAC,iBAAiB,qBAAqB,WAAW,cAAc,UAAU;AACvF,0BAAgB;AAChB,wBAAc,SAAS;AAEvB,cAAI,WAAW;AACX;UACJ;QACJ;MACJ;IACJ;AACA,WAAO;EACX;;;;EAKQ,6BACJ,KACA,WACA,SACA,WACA,mBAA4C;AAE5C,QAAI,gBAA4C;AAEhD,aAAS,QAAQ,KAAK,eAAe,QAAQ,KAAK,gBAAgB,KAAK,eAAe,SAAS,GAAG;AAC9F,YAAM,KAAK,UAAU,KAAK;AAC1B,YAAM,KAAK,UAAU,QAAQ,CAAC;AAC9B,YAAM,KAAK,UAAU,QAAQ,CAAC;AAE9B,UAAI,qBAAqB,CAAC,kBAAkB,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE,GAAG;AACtE;MACJ;AAEA,YAAM,uBAAuB,IAAI,mBAAmB,IAAI,IAAI,EAAE;AAE9D,UAAI,sBAAsB;AACtB,YAAI,qBAAqB,WAAW,GAAG;AACnC;QACJ;AAEA,YAAI,aAAa,CAAC,iBAAiB,qBAAqB,WAAW,cAAc,UAAU;AACvF,0BAAgB;AAChB,wBAAc,SAAS,QAAQ;AAE/B,cAAI,WAAW;AACX;UACJ;QACJ;MACJ;IACJ;AACA,WAAO;EACX;;EAGO,WAAQ;AACX,QAAI,KAAK,mBAAmB;AACxB,WAAK,oBAAoB;IAC7B;EACJ;;;;;;;;EASO,MAAM,SAAuB,kBAAuB;AACvD,UAAM,SAAS,IAAI,SAAQ,KAAK,eAAe,KAAK,eAAe,KAAK,eAAe,KAAK,YAAY,KAAK,YAAY,SAAS,kBAAkB,KAAK;AAEzJ,QAAI,CAAC,KAAK,UAAU;AAChB,YAAM,eAAe,KAAK,gBAAe;AAEzC,UAAI,CAAC,cAAc;AACf,eAAO;MACX;AAEA,aAAO,gBAAgB,IAAI,aAAa,aAAa,SAAS,aAAa,OAAO;IACtF;AAEA,WAAO;EACX;;;;;;EAQO,QAAQ,YAAY,OAAK;AAC5B,QAAI,KAAK,mBAAmB;AACxB,WAAK,MAAM,SAAQ,EAAG,UAAS,EAAG,eAAe,KAAK,iBAAiB;AACvE,WAAK,oBAAoB;IAC7B;AAGA,UAAM,QAAQ,KAAK,MAAM,UAAU,QAAQ,IAAI;AAC/C,SAAK,MAAM,UAAU,OAAO,OAAO,CAAC;AAEpC,SAAK,eAAe,QAAW,SAAS;EAC5C;;;;;EAMO,eAAY;AACf,WAAO;EACX;;;;;;;;;;;;EAaO,OAAO,kBACV,eACA,YACA,YACA,MACA,eACA,oBAA6B,MAAI;AAEjC,QAAI,iBAAiB,OAAO;AAC5B,QAAI,iBAAiB,CAAC,OAAO;AAE7B,UAAM,iBAAiB,iBAAiB;AACxC,UAAM,UAAU,eAAgB,WAAU;AAE1C,aAAS,QAAQ,YAAY,QAAQ,aAAa,YAAY,SAAS;AACnE,YAAM,cAAc,QAAQ,KAAK;AAEjC,UAAI,cAAc,gBAAgB;AAC9B,yBAAiB;MACrB;AACA,UAAI,cAAc,gBAAgB;AAC9B,yBAAiB;MACrB;IACJ;AAEA,WAAO,IAAI,SAAQ,eAAe,gBAAgB,iBAAiB,iBAAiB,GAAG,YAAY,YAAY,MAAM,eAAe,iBAAiB;EACzJ;;;;ACtwBE,SAAU,qBAAqB,UAAkB;AACnD,MAAI,SAAS,QAAQ,YAAY,MAAM,IAAI;AACvC,aAAS,KAAK,YAAY;EAC9B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACA,MAAI,SAAS,QAAQ,aAAa,MAAM,IAAI;AACxC,aAAS,KAAK,aAAa;EAC/B;AACJ;AAGM,SAAU,kCAAkC,eAAkC,iBAAoC,SAAiB;AACrI,QAAM,YAAY,CAAC,EAAE,cAAc,aAAa,gBAAgB;AAChE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAElE,MAAI;AAAW,YAAQ,KAAK,mBAAmB;AAC/C,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACjD,MAAI;AAAY,YAAQ,KAAK,oBAAoB;AACrD;AAGM,SAAU,4BAA4B,eAAkC,iBAAoC,SAA4B;AAC1I,MAAI,UAAU;AAEd,QAAM,YAAY,CAAC,EAAE,cAAc,aAAa,gBAAgB;AAChE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAClE,QAAM,aAAa,CAAC,EAAE,cAAc,cAAc,gBAAgB;AAGlE,MAAI,QAAQ,WAAW,MAAM,WAAW;AACpC,YAAQ,WAAW,IAAI;AACvB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AACA,MAAI,QAAQ,YAAY,MAAM,YAAY;AACtC,YAAQ,YAAY,IAAI;AACxB,cAAU;EACd;AAEA,SAAO;AACX;AAGM,SAAU,cAAc,QAAgB,eAAkC,iBAAkC;AAC9G,MAAI,YAAY,cAAc,aAAa,gBAAgB;AAC3D,eAAa,QAAQ,cAAc,SAAS;AAC5C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AAC7C,cAAY,cAAc,cAAc,gBAAgB;AACxD,eAAa,QAAQ,eAAe,SAAS;AACjD;AAEA,SAAS,aAAa,QAAgB,aAAqB,WAA0B;AACjF,MAAI,WAAW;AACX,WAAO,UAAU,aAAa,UAAU,OAAO,GAAG,UAAU,OAAO,GAAG,UAAU,OAAO,GAAG,UAAU,CAAC;EACzG;AACJ;;;ACjFA,IAAM,gBAAgB,OAAO,MAAK;AAClC,IAAM,uBAAuB;EACzB,uBAAuB;EACvB,QAAQ;EACR,SAAS;EACT,IAAI;EACJ,KAAK;EACL,OAAO;;AASL,SAAU,aAAa,SAAc,QAAgB,OAAY;AACnE,MAAI,CAAC,WAAW,QAAQ,kBAAkB,KAAM,QAAQ,WAAW,QAAQ,QAAQ,kBAAkB,KAAK,GAAI;AAC1G,UAAM,SAAS,MAAM;AACrB,QAAI,OAAO,SAAS,GAAA;AAChB,aAAO,MAAM,kEAAkE,EAAE;IACrF;AACA,WAAO,SAAS,4BAA4B,KAAO,KAAK,IAAI,OAAO,OAAO,CAAG,IAAI,KAAK,IAAI;EAC9F;AACJ;AASM,SAAU,kBAAkB,OAAc,MAAqB,QAAiB,cAAc,OAAK;AACrG,MAAI,UAAU,MAAM,eAAe,CAAC,QAAQ,KAAK,aAAa,MAAM,YAAY,GAAA;AAC5E,WAAO,UAAU,aAAa,MAAM,SAAS,MAAM,UAAU,MAAM,QAAQ,MAAM,UAAU;AAE3F,QAAI,aAAa;AACb,YAAM,SAAS,mBAAmB,eAAe,MAAM,UAAS,EAAG,uBAAuB;AAC1F,aAAO,UAAU,aAAa,aAAa;IAC/C,OAAO;AACH,aAAO,UAAU,aAAa,MAAM,QAAQ;IAChD;EACJ;AACJ;AAgBM,SAAU,2CACZ,oBACA,SACA,SACA,MACA,kBACA,gBACA,iBACA,YACA,aACA,eAAsB;AAEtB,QAAM,sBAAsB,mBAAmB,qBAAqB,mBAAmB;AACvF,MAAI,uBAAuB,GAAG;AAC1B,WAAO;EACX;AAEA,UAAQ,KAAK,sBAAsB;AAEnC,MAAI,mBAAmB;AAAc,YAAQ,KAAK,yCAAyC;AAC3F,MAAI,mBAAmB;AAAY,YAAQ,KAAK,uCAAuC;AACvF,MAAI,mBAAmB;AAAa,YAAQ,KAAK,wCAAwC;AACzF,MAAI,mBAAmB;AAAQ,YAAQ,KAAK,mCAAmC;AAC/E,MAAI,mBAAmB;AAAS,YAAQ,KAAK,oCAAoC;AACjF,MAAI,mBAAmB;AAAW,YAAQ,KAAK,sCAAsC;AAErF,MAAI,mBAAmB,qBAAqB;AAAkB,YAAQ,KAAK,+BAA+B;AAC1G,MAAI,mBAAmB,mBAAmB;AAAgB,YAAQ,KAAK,6BAA6B;AACpG,MAAI,mBAAmB,oBAAoB;AAAiB,YAAQ,KAAK,8BAA8B;AACvG,MAAI,mBAAmB,eAAe;AAAY,YAAQ,KAAK,yBAAyB;AACxF,MAAI,mBAAmB,gBAAgB;AAAa,YAAQ,KAAK,0BAA0B;AAC3F,MAAI,mBAAmB,kBAAkB;AAAe,YAAQ,KAAK,4BAA4B;AAEjG,UAAQ,KAAK,mCAAmC,mBAAmB;AAEnE,MAAI,mBAAmB,0BAA0B;AAC7C,YAAQ,KAAK,8BAA8B;EAC/C;AAEA,uBAAqB,wBAAwB;AAC7C,uBAAqB,SAAS;AAC9B,uBAAqB,UAAU;AAC/B,uBAAqB,KAAK;AAC1B,uBAAqB,MAAM;AAC3B,uBAAqB,QAAQ;AAE7B,mCAAiC,SAAS,MAAM,sBAAsB,gBAAgB;AACtF,SAAO;AACX;AAyBM,SAAU,iCAAiC,SAAmB,MAAoB,SAAc,mBAAmB,MAAI;AACzH,QAAM,cAAc,QAAQ,uBAAuB;AAEnD,MAAI,cAAc,KAAK,YAAY,mBAAmB;AAClD,UAAM,qBAAqB,YAAY,kBAAkB,QAAO,EAAG;AACnE,UAAM,UAAW,KAAc;AAC/B,QAAI,mCAAS,0BAA0B;AACnC;IACJ;AACA,UAAM,WAAW,WAAW,QAAQ,qBAAqB;AACzD,UAAM,SAAS,WAAW,QAAQ,mBAAmB,QAAQ,QAAQ;AACrE,UAAM,UAAU,WAAW,QAAQ,oBAAoB,QAAQ,SAAS;AACxE,UAAM,KAAK,WAAW,QAAQ,eAAe,QAAQ,KAAK;AAC1D,UAAM,MAAM,WAAW,QAAQ,gBAAgB,QAAQ,KAAK;AAC5D,UAAM,QAAQ,WAAW,QAAQ,kBAAkB,QAAQ,OAAO;AAClE,aAAS,QAAQ,GAAG,QAAQ,aAAa,SAAS;AAC9C,UAAI,UAAU;AACV,gBAAQ,KAAK,aAAU,KAAA;MAC3B;AAEA,UAAI,QAAQ;AACR,gBAAQ,KAAK,WAAU,KAAA;MAC3B;AAEA,UAAI,SAAS;AACT,gBAAQ,KAAK,YAAU,KAAA;MAC3B;AAEA,UAAI,IAAI;AACJ,gBAAQ,KAAK,QAAU,KAAM;MACjC;AAEA,UAAI,KAAK;AACL,gBAAQ,KAAK,SAAU,KAAO;MAClC;AAEA,UAAI,OAAO;AACP,gBAAQ,KAAK,UAAU,KAAA;MAC3B;AAEA,UAAI,QAAQ,SAAS,oBAAoB;AACrC,eAAO,MAAM,gDAAgD,KAAK,IAAI;MAC1E;IACJ;EACJ;AACJ;AAOM,SAAU,2BAA2B,SAAmB,wBAAiC,OAAK;AAChG,UAAQ,KAAK,QAAQ;AACrB,UAAQ,KAAK,QAAQ;AACrB,UAAQ,KAAK,QAAQ;AACrB,UAAQ,KAAK,QAAQ;AACrB,MAAI,uBAAuB;AACvB,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,KAAK,gBAAgB;EACjC;AACJ;AAOM,SAAU,0BAA0B,cAA4B,QAAc;AAChF,QAAM,UAAiB,aAAc;AACrC,MAAI,CAAC,gBAAgB,CAAC,SAAS;AAC3B;EACJ;AAEA,SAAO,cAAc,yBAAyB,QAAQ,UAAU;AACpE;AAOM,SAAU,uBAAuB,QAAgB,UAAuB;AAC1E,WAAS,aAAa,QAAQ,OAAO;AACzC;AASM,SAAU,0BAA0B,SAAsB,SAAc,KAAW;AACrF,UAAQ,WAAW;AACnB,UAAQ,GAAG,IAAI;AACf,MAAI,QAAQ,wBAAwB,QAAQ,iBAAgB,EAAG,gBAAe,GAAI;AAC9E,YAAQ,MAAM,UAAU,IAAI,QAAQ,mBAAmB;AACvD,YAAQ,YAAY,QAAQ,mBAAmB,EAAE,IAAI;EACzD,OAAO;AACH,YAAQ,MAAM,UAAU,IAAI;EAChC;AACJ;AAQM,SAAU,kBAAkB,SAAsB,eAA8B,KAAW;AAC7F,QAAM,SAAS,QAAQ,iBAAgB;AAEvC,gBAAc,aAAa,MAAM,UAAU,MAAM;AACrD;AAQM,SAAU,yCAAyC,SAAmB,MAAoB,SAAY;AACxG,QAAM,UAAU,QAAQ,gCAAgC,KAAK,QAAQ,WAAW;AAEhF,MAAI,SAAS;AACT,YAAQ,KAAK,uCAAuC;EACxD;AACJ;AAGA,SAAS,iCAAiC,QAAsB,QAAoB;AAChF,SAAO,IAAI,MAAM;AAEjB,SAAO;AACX;AAQM,SAAU,oBAAoB,MAAqB,QAAiB,sBAA2C;AACjH,MAAI,CAAC,UAAU,CAAC,MAAM;AAClB;EACJ;AACA,MAAI,KAAK,4BAA4B,OAAO,8BAA8B;AACtE,SAAK,2BAA2B;EACpC;AAEA,MAAI,KAAK,YAAY,KAAK,4BAA4B,KAAK,UAAU;AACjE,UAAM,WAAW,KAAK;AAEtB,QAAI,SAAS,6BAA6B,OAAO,gBAAgB,kBAAkB,IAAI,IAAI;AACvF,YAAM,cAAc,SAAS,0BAA0B,IAAI;AAC3D,aAAO,WAAW,eAAe,WAAW;AAC5C,aAAO,SAAS,oBAAoB,KAAO,SAAS,MAAM,SAAS,EAAE;IACzE,OAAO;AACH,YAAM,WAAW,SAAS,qBAAqB,IAAI;AAEnD,UAAI,UAAU;AACV,eAAO,YAAY,UAAU,QAAQ;AACrC,YAAI,wBAAwB,KAAK,SAAQ,EAAG,mBAAmB,KAAK,SAAQ,EAAG,gBAAiB,SAAS,CAAA,GAAA;AACrG,cAAI,CAAC,qBAAqB,cAAc,KAAK,QAAQ,GAAG;AACpD,iCAAqB,cAAc,KAAK,QAAQ,IAAI,SAAS,MAAK;UACtE;AACA,iBAAO,YAAY,kBAAkB,qBAAqB,cAAc,KAAK,QAAQ,CAAC;AACtF,2CAAiC,UAAU,qBAAqB,cAAc,KAAK,QAAQ,CAAC;QAChG;MACJ;IACJ;EACJ;AACJ;AAqBM,SAAU,UAAU,OAAc,YAAoB,OAAc,QAAgB,aAAsB,iBAAiB,MAAI;AACjI,QAAM,WAAW,YAAY,OAAO,QAAQ,aAAa,cAAc;AAC3E;AAUM,SAAU,WAAW,OAAc,MAAoB,QAAgB,SAAc,wBAAwB,GAAC;AAChH,QAAM,MAAM,KAAK,IAAI,KAAK,aAAa,QAAQ,qBAAqB;AAEpE,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,UAAM,QAAQ,KAAK,aAAa,CAAC;AACjC,cAAU,OAAO,GAAG,OAAO,QAAQ,OAAO,YAAY,YAAY,UAAU,QAAQ,cAAc,GAAG,KAAK,cAAc;EAC5H;AACJ;AASM,SAAU,0BAA0B,SAAmB,MAAoB,SAAc,WAA0B;AACrH,MAAI,QAAQ,sBAAsB,IAAI,GAAG;AACrC,cAAU,uBAAuB,GAAG,IAAI;AAExC,YAAQ,KAAK,iBAAU;AACvB,YAAQ,KAAK,iBAAU;AACvB,QAAI,QAAQ,sBAAsB,IAAI,GAAG;AACrC,cAAQ,KAAK,sBAAU;AACvB,cAAQ,KAAK,sBAAU;IAC3B;EACJ;AACJ;AAOM,SAAU,8BAA8B,SAAmB,SAAwB;AACrF,MAAI,QAAQ,WAAW,KAAK,QAAQ,gBAAgB,GAAG;AACnD,+BAA2B,SAAS,CAAC,CAAC,QAAQ,kBAAkB,CAAC;EACrE;AAEA,MAAI,QAAQ,gBAAgB;AACxB,YAAQ,KAAK,eAAU;EAC3B;AACJ;AAUM,SAAU,0BAA0B,SAAc,WAA4B,wBAAwB,GAAG,OAAO,GAAC;AACnH,MAAI,oBAAoB;AACxB,WAAS,aAAa,GAAG,aAAa,uBAAuB,cAAc;AACvE,QAAI,CAAC,QAAQ,UAAU,UAAU,GAAG;AAChC;IACJ;AAEA,QAAI,aAAa,GAAG;AAChB,0BAAoB,OAAO;AAC3B,gBAAU,YAAY,mBAAmB,UAAU,UAAU;IACjE;AAEA,QAAI,CAAC,QAAQ,SAAS,GAAG;AACrB,UAAI,QAAQ,WAAW,UAAU,GAAG;AAChC,kBAAU,YAAY,MAAM,WAAW,UAAU;MACrD;AAEA,UAAI,QAAQ,cAAc,UAAU,GAAG;AACnC,kBAAU,YAAY,MAAM,cAAc,UAAU;MACxD;AAEA,UAAI,QAAQ,eAAe,UAAU,GAAG;AACpC,kBAAU,YAAY,MAAM,eAAe,UAAU;MACzD;AAEA,UAAI,QAAQ,kBAAkB,UAAU,GAAG;AACvC,kBAAU,YAAY,MAAM,kBAAkB,UAAU;MAC5D;AAEA,UAAI,QAAQ,cAAc,UAAU,GAAG;AACnC,kBAAU,YAAY,MAAM,cAAc,UAAU;MACxD;AAEA,UAAI,QAAQ,mBAAmB,UAAU,GAAG;AACxC,kBAAU,YAAY,MAAM,mBAAmB,UAAU;MAC7D;IACJ;EACJ;AACA,SAAO;AACX;AAQM,SAAU,YAAY,MAAoB,OAAY;AACxD,SAAO,MAAM,cAAc,KAAK,YAAY,MAAM,YAAY;AAClE;AAaM,SAAU,sBACZ,MACA,OACA,qBACA,aACA,YACA,WACA,SACA,wBAAiC,OAAK;AAEtC,MAAI,QAAQ,eAAe;AACvB,YAAQ,kBAAkB,IAAI;AAC9B,YAAQ,WAAW,IAAI;AACvB,YAAQ,KAAK,IAAI,cAAc,YAAY,MAAM,KAAK;AACtD,YAAQ,mBAAmB,IAAI,KAAK;AACpC,YAAQ,WAAW,IAAI;AACvB,YAAQ,oBAAoB,IAAI;EACpC;AACJ;AAYM,SAAU,wBAAwB,OAAc,MAAoB,SAAc,mBAA4B,wBAAwB,GAAG,kBAAkB,OAAK;AAClK,MAAI,CAAC,QAAQ,iBAAiB;AAC1B,WAAO,QAAQ;EACnB;AAEA,MAAI,aAAa;AACjB,QAAM,QAAQ;IACV,aAAa,QAAQ;;IACrB,aAAa;IACb,cAAc;IACd,eAAe;IACf,iBAAiB;;AAGrB,MAAI,MAAM,iBAAiB,CAAC,iBAAiB;AACzC,eAAW,SAAS,KAAK,cAAc;AACnC,6BAAuB,OAAO,MAAM,OAAO,YAAY,SAAS,mBAAmB,KAAK;AAExF;AACA,UAAI,eAAe,uBAAuB;AACtC;MACJ;IACJ;EACJ;AAEA,UAAQ,cAAc,IAAI,MAAM;AAChC,UAAQ,SAAS,IAAI,MAAM;AAG3B,WAAS,QAAQ,YAAY,QAAQ,uBAAuB,SAAS;AACjE,QAAI,QAAQ,UAAU,KAAK,MAAM,QAAW;AACxC,cAAQ,UAAU,KAAK,IAAI;AAC3B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ,aAAa,KAAK,IAAI;AAC9B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,WAAW,KAAK,IAAI;AAC5B,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,mBAAmB,KAAK,IAAI;AACpC,cAAQ,0BAA0B,KAAK,IAAI;AAC3C,cAAQ,2BAA2B,KAAK,IAAI;AAC5C,cAAQ,qBAAqB,KAAK,IAAI;AACtC,cAAQ,0BAA0B,KAAK,IAAI;AAC3C,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ,kBAAkB,KAAK,IAAI;AACnC,cAAQ,cAAc,KAAK,IAAI;AAC/B,cAAQ,mBAAmB,KAAK,IAAI;AACpC,cAAQ,eAAe,KAAK,IAAI;AAChC,cAAQ,qBAAqB,KAAK,IAAI;AACtC,cAAQ,wBAAwB,KAAK,IAAI;IAC7C;EACJ;AAEA,QAAM,OAAO,MAAM,UAAS,EAAG,QAAO;AAEtC,MAAI,QAAQ,aAAa,MAAM,QAAW;AACtC,UAAM,cAAc;EACxB;AAEA,UAAQ,aAAa,IACjB,MAAM,kBAAmB,KAAK,sBAAsB,KAAK,+BAAiC,KAAK,0BAA0B,KAAK;AAClI,UAAQ,kBAAkB,IAAI,MAAM;AAEpC,MAAI,MAAM,aAAa;AACnB,YAAQ,QAAO;EACnB;AAEA,SAAO,MAAM;AACjB;AAiBM,SAAU,uBACZ,OACA,MACA,OACA,YACA,SACA,mBACA,OAMC;AAED,QAAM,cAAc;AAEpB,MAAI,QAAQ,UAAU,UAAU,MAAM,QAAW;AAC7C,UAAM,cAAc;EACxB;AAEA,UAAQ,UAAU,UAAU,IAAI;AAEhC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,eAAe,UAAU,IAAI;AACrC,UAAQ,aAAa,UAAU,IAAI;AACnC,UAAQ,cAAc,UAAU,IAAI;AAEpC,QAAM,4BAA4B,SAAS,UAAU;AAGrD,UAAQ,2BAA2B,UAAU,IAAI;AACjD,UAAQ,uBAAuB,UAAU,IAAI;AAC7C,UAAQ,2BAA2B,UAAU,IAAI;AAEjD,UAAQ,MAAM,aAAa;IACvB,KAAK,eAAe;AAChB,cAAQ,uBAAuB,UAAU,IAAI;AAC7C;IACJ,KAAK,eAAe;AAChB,cAAQ,2BAA2B,UAAU,IAAI;AACjD;IACJ,KAAK,eAAe;AAChB,cAAQ,2BAA2B,UAAU,IAAI;AACjD;EACR;AAGA,MAAI,qBAAqB,CAAC,MAAM,SAAS,aAAa,GAAG,GAAG,CAAC,GAAG;AAC5D,UAAM,kBAAkB;EAC5B;AAGA,UAAQ,WAAW,UAAU,IAAI;AACjC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,mBAAmB,UAAU,IAAI;AACzC,UAAQ,0BAA0B,UAAU,IAAI;AAChD,UAAQ,2BAA2B,UAAU,IAAI;AACjD,UAAQ,qBAAqB,UAAU,IAAI;AAC3C,UAAQ,0BAA0B,UAAU,IAAI;AAChD,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,eAAe,UAAU,IAAI;AACrC,UAAQ,kBAAkB,UAAU,IAAI;AACxC,UAAQ,cAAc,UAAU,IAAI;AACpC,UAAQ,mBAAmB,UAAU,IAAI;AACzC,UAAQ,eAAe,UAAU,IAAI;AACrC,UAAQ,qBAAqB,UAAU,IAAI;AAC3C,UAAQ,wBAAwB,UAAU,IAAI;AAE9C,MAAI,QAAQ,KAAK,kBAAkB,MAAM,kBAAkB,MAAM,eAAe;AAC5E,UAAM,kBAAkB,MAAM,mBAAmB,MAAM,YAAY,KAAK,MAAM,mBAAkB;AAChG,QAAI,iBAAiB;AACjB,YAAM,YAAY,gBAAgB,aAAY;AAC9C,UAAI,WAAW;AACX,YAAI,UAAU,cAAc,UAAU,WAAW,SAAS,GAAG;AACzD,gBAAM,gBAAgB;AACtB,0BAAgB,eAAe,SAAS,UAAU;QACtD;MACJ;IACJ;EACJ;AAEA,MAAI,MAAM,gBAAgB,eAAe,kBAAkB;AACvD,UAAM,eAAe;AACrB,YAAQ,qBAAqB,UAAU,IAAI;AAC3C,YAAQ,uBAAuB,UAAU,IAAI,MAAM,gBAAgB,eAAe;EACtF,OAAO;AACH,YAAQ,qBAAqB,UAAU,IAAI;AAC3C,YAAQ,uBAAuB,UAAU,IAAI;EACjD;AACJ;AAYM,SAAU,kCACZ,OACA,QACA,UACA,SACA,cACA,eAAkC,MAClC,mBAA4B,OAAK;AAEjC,MAAI,UAAU,wBAAwB,OAAO,OAAO;AAEpD,MAAI,iBAAiB,OAAO;AACxB,cAAU,4BAA4B,UAAU,OAAO,OAAO;EAClE;AAEA,MAAI,QAAQ,cAAc,MAAM,CAAC,OAAO,cAAa,GAAI;AACrD,YAAQ,cAAc,IAAI,CAAC,QAAQ,cAAc;AACjD,cAAU;EACd;AAEA,MAAI,QAAQ,WAAW,MAAM,cAAc;AACvC,YAAQ,WAAW,IAAI;AACvB,cAAU;EACd;AAEA,MAAI,QAAQ,gBAAgB,MAAM,kBAAkB;AAChD,YAAQ,gBAAgB,IAAI;AAC5B,cAAU;EACd;AAEA,MAAI,SAAS;AACT,YAAQ,kBAAiB;EAC7B;AACJ;AAOM,SAAU,uBAAuB,MAAoB,SAAY;AACnE,MAAI,KAAK,YAAY,KAAK,4BAA4B,KAAK,UAAU;AACjE,YAAQ,sBAAsB,IAAI,KAAK;AAEvC,UAAM,8BAA8B,QAAQ,aAAa,MAAM;AAE/D,QAAI,KAAK,SAAS,6BAA6B,6BAA6B;AACxE,cAAQ,aAAa,IAAI;IAC7B,OAAO;AACH,cAAQ,cAAc,IAAI,KAAK,SAAS,MAAM,SAAS;AACvD,cAAQ,aAAa,IAAI,8BAA8B,QAAQ;AAE/D,YAAM,kBAAkB,KAAK,SAAQ,EAAG;AACxC,UAAI,mBAAmB,gBAAgB,SAAS;AAC5C,cAAM,cAAc,gBAAgB,oBAAoB,QAAQ,IAAI,MAAM;AAC1E,gBAAQ,wBAAwB,IAAI;MACxC;IACJ;EACJ,OAAO;AACH,YAAQ,sBAAsB,IAAI;AAClC,YAAQ,cAAc,IAAI;AAC1B,QAAI,QAAQ,aAAa,MAAM,QAAW;AACtC,cAAQ,aAAa,IAAI;IAC7B;EACJ;AACJ;AAOM,SAAU,8BAA8B,MAAoB,SAAY;AAC1E,QAAM,UAAiB,KAAM;AAC7B,MAAI,SAAS;AACT,YAAQ,iBAAiB,IAAI,QAAQ,eAAe,QAAQ,KAAK;AACjE,YAAQ,kBAAkB,IAAI,QAAQ,gBAAgB,QAAQ,KAAK;AACnE,YAAQ,sBAAsB,IAAI,QAAQ,oBAAoB,QAAQ,SAAS;AAC/E,YAAQ,qBAAqB,IAAI,QAAQ,mBAAmB,QAAQ,QAAQ;AAC5E,YAAQ,uBAAuB,IAAI,QAAQ;AAC3C,YAAQ,oBAAoB,IAAI,QAAQ;AAExC,YAAQ,2BAA2B,IAAI,QAAQ;AAC/C,YAAQ,4BAA4B,IAAI,QAAQ;AAChD,YAAQ,gCAAgC,IAAI,QAAQ;AACpD,YAAQ,+BAA+B,IAAI,QAAQ;AACnD,YAAQ,iCAAiC,IAAI,QAAQ;AACrD,YAAQ,8BAA8B,IAAI,QAAQ;AAElD,YAAQ,uBAAuB,IAAI,QAAQ,qBAAqB,QAAQ;AACxE,YAAQ,cAAc,IAAI,QAAQ,uBAAuB,IAAI;AAE7D,YAAQ,sBAAsB,IAAI,QAAQ;EAC9C,OAAO;AACH,YAAQ,iBAAiB,IAAI;AAC7B,YAAQ,kBAAkB,IAAI;AAC9B,YAAQ,sBAAsB,IAAI;AAClC,YAAQ,qBAAqB,IAAI;AACjC,YAAQ,uBAAuB,IAAI;AACnC,YAAQ,oBAAoB,IAAI;AAEhC,YAAQ,2BAA2B,IAAI;AACvC,YAAQ,4BAA4B,IAAI;AACxC,YAAQ,gCAAgC,IAAI;AAC5C,YAAQ,+BAA+B,IAAI;AAC3C,YAAQ,iCAAiC,IAAI;AAC7C,YAAQ,+BAA+B,IAAI;AAE3C,YAAQ,cAAc,IAAI;AAC1B,YAAQ,uBAAuB,IAAI;EACvC;AACJ;AAOM,SAAU,sCAAsC,MAAoB,SAAY;AAClF,QAAM,UAAiB,KAAM;AAC7B,UAAQ,gCAAgC,IAAI,WAAW,QAAQ,YAAY,OAAO;AACtF;AAaM,SAAU,4BACZ,MACA,SACA,gBACA,UACA,kBAAkB,OAClB,iBAAiB,MACjB,0BAA0B,MAAI;AAE9B,MAAI,CAAC,QAAQ,uBAAuB,QAAQ,iBAAiB,QAAQ,YAAY,QAAQ,aAAa,QAAQ,MAAM;AAChH,WAAO;EACX;AAEA,UAAQ,WAAW,QAAQ;AAC3B,UAAQ,OAAO,QAAQ;AAEvB,UAAQ,QAAQ,IAAI,QAAQ,gBAAgB,KAAK,sBAAsB,QAAA;AAEvE,MAAI,QAAQ,gBAAgB,KAAK,sBAAsB,SAAS,GAAC;AAC7D,YAAQ,SAAS,IAAI;EACzB;AAEA,WAAS,IAAI,GAAG,KAAK,GAAA,EAAA,GAAA;AACjB,YAAQ,OAAO,CAAC,IAAI,QAAQ,WAAW,KAAK,sBAAsB,KAAK,MAAM,IAAI,KAAK,CAAC,EAAE,IAAI;EACjG;AAEA,MAAI,gBAAgB;AAChB,UAAM,kBAAkB,KAAK,mBAAmB,KAAK,sBAAsB,OAAA;AAC3E,YAAQ,aAAa,IAAI;AACzB,YAAQ,aAAa,IAAI,KAAK,kBAAkB,mBAAmB;EACvE;AAEA,MAAI,KAAK,sBAAsB,eAAU,MAAA,KAAA,gBAA4B,KAAA,mBAAqB;AACtF,YAAQ,gBAAgB,IAAI;EAChC;AAEA,MAAI,UAAU;AACV,2BAAuB,MAAM,OAAO;EACxC;AAEA,MAAI,iBAAiB;AACjB,kCAA8B,MAAM,OAAO;EAC/C;AAEA,MAAI,yBAAyB;AACzB,0CAAsC,MAAM,OAAO;EACvD;AAEA,SAAO;AACX;AAOM,SAAU,2BAA2B,OAAc,SAAY;AACjE,MAAI,MAAM,cAAc;AACpB,UAAM,oBAAoB,QAAQ;AAClC,YAAQ,YAAY,MAAM,aAAa,uBAAuB,QAAQ,MAAM,aAAa,mBAAmB,aAAY,IAAK;AAC7H,QAAI,QAAQ,aAAa,mBAAmB;AACxC,cAAQ,kBAAiB;IAC7B;EACJ;AACJ;AAQM,SAAU,qBAAqB,OAAc,SAAc,mBAA0B;AACvF,QAAM,iBAAiB,QAAQ;AAC/B,QAAM,uBAAuB,QAAQ;AAErC,UAAQ,iCAAiC,MAAM,mCAAmC;AAClF,UAAQ,wCAAwC,CAAC,MAAM,UAAS,EAAG,QAAO,EAAG;AAE7E,MAAI,mBAAmB,QAAQ,kCAAkC,yBAAyB,QAAQ,uCAAuC;AACrI,YAAQ,kBAAiB;EAC7B;AACJ;AAQM,SAAU,yBAAyB,OAAc,SAAc,gBAAuB;AACxF,QAAM,kBAAkB,QAAQ;AAEhC,MAAI,CAAC,QAAQ,kBAAkB;AAC3B;EACJ;AAEA,QAAM,eAAe;IACjB;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;IAEX;MACI,MAAM;MACN,QAAQ;MACR,OAAO;;;AAIf,MAAI,MAAM,mBAAmB,MAAM,gBAAgB,WAAW,gBAAgB;AAC1E,YAAQ,UAAU;AAClB,YAAQ,kBAAkB,MAAM,gBAAgB;AAChD,YAAQ,4BAA4B,MAAM,gBAAgB;AAC1D,YAAQ,gBAAgB;AACxB,YAAQ,sBAAsB;AAE9B,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,YAAM,QAAQ,MAAM,gBAAgB,SAAS,aAAa,CAAC,EAAE,IAAI;AACjE,UAAI,UAAU,IAAI;AACd,gBAAQ,aAAa,CAAC,EAAE,MAAM,IAAI;AAClC,gBAAQ,aAAa,CAAC,EAAE,KAAK,IAAI;MACrC,OAAO;AACH,gBAAQ,aAAa,CAAC,EAAE,MAAM,IAAI;MACtC;IACJ;EACJ,OAAO;AACH,YAAQ,UAAU;AAClB,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC1C,cAAQ,aAAa,CAAC,EAAE,MAAM,IAAI;IACtC;EACJ;AAEA,MAAI,QAAQ,WAAW,iBAAiB;AACpC,YAAQ,kBAAiB;AACzB,YAAQ,2BAA0B;EACtC;AACJ;AAQM,SAAU,wBAAwB,OAAc,SAAY;AAC9D,MAAI,UAAU;AAEd,MAAI,MAAM,cAAc;AACpB,UAAM,WAAW,QAAQ,qBAAqB,IAAI,IAAI;AACtD,UAAM,WAAW,QAAQ,oBAAoB,IAAI,IAAI;AACrD,UAAM,UAAU,MAAM,aAAa,SAAS,IAAA,IAAA;AAC5C,UAAM,UAAU,MAAM,aAAa,SAAS,IAAA,IAAA;AAE5C,QAAI,WAAW,WAAW,WAAW,SAAS;AAC1C,cAAQ,qBAAqB,IAAI,YAAY;AAC7C,cAAQ,oBAAoB,IAAI,YAAY;AAC5C,gBAAU;IACd;EACJ;AAEA,SAAO;AACX;AAYM,SAAU,mCACZ,YACA,cACA,cACA,uBACA,qBAAyC,MACzC,wBAAwB,OACxB,kBAAkB,OAAK;AAEvB,MAAI,oBAAoB;AACpB,uBAAmB,KAAK,UAAU,UAAU;EAChD;AAEA,MAAI,uBAAuB;AACvB;EACJ;AAEA,eAAa,KACT,eAAe,YACf,kBAAkB,YAClB,mBAAmB,YACnB,oBAAoB,YACpB,gBAAgB,YAChB,iBAAiB,YACjB,kBAAkB,YAClB,iBAAiB,YACjB,gBAAgB,YAChB,gBAAgB,YAChB,gBAAgB,UAAU;AAG9B,eAAa,KAAK,kBAAkB,UAAU;AAC9C,eAAa,KAAK,iBAAiB,UAAU;AAE7C,eAAa,KACT,iBAAiB,YACjB,uBAAuB,YACvB,0BAA0B,YAC1B,oBAAoB,YACpB,qBAAqB,YACrB,mBAAmB,UAAU;AAGjC,MAAI,uBAAuB;AACvB,iBAAa,KAAK,2BAA2B,UAAU;AACvD,iBAAa,KAAK,4BAA4B,UAAU;EAC5D;AACA,MAAI,iBAAiB;AACjB,iBAAa,KAAK,oBAAoB,UAAU;EACpD;AACJ;AASM,SAAU,+BAA+B,uBAA0D,cAAyB,SAAe,wBAAwB,GAAC;AACtK,MAAI;AACJ,MAAI;AAEJ,MAA6B,sBAAuB,eAAe;AAC/D,UAAM,UAAkC;AACxC,mBAAe,QAAQ;AACvB,yBAAqB,QAAQ;AAC7B,mBAAe,QAAQ;AACvB,cAAU,QAAQ;AAClB,4BAAwB,QAAQ,yBAAyB;EAC7D,OAAO;AACH,mBAAyB;AACzB,QAAI,CAAC,cAAc;AACf,qBAAe,CAAA;IACnB;EACJ;AAEA,WAAS,aAAa,GAAG,aAAa,uBAAuB,cAAc;AACvE,QAAI,CAAC,QAAQ,UAAU,UAAU,GAAG;AAChC;IACJ;AACA,uCACI,YACA,cACA,cACA,QAAQ,0BAA0B,UAAU,GAC5C,oBACA,OACA,QAAQ,oBAAoB,UAAU,CAAC;EAE/C;AAEA,MAAI,QAAQ,uBAAuB,GAAG;AAClC,iBAAa,KAAK,uBAAuB;AACzC,iBAAa,KAAK,kBAAkB;EACxC;AAEA,MAAI,QAAQ,gCAAgC,GAAG;AAC3C,iBAAa,KAAK,8BAA8B;AAChD,iBAAa,KAAK,yCAAyC;AAC3D,iBAAa,KAAK,0BAA0B;AAC5C,iBAAa,KAAK,6BAA6B;EACnD;AACJ;;;ACvnCM,IAAO,uBAAP,MAA2B;;;;EAI7B,cAAA;AACI,SAAK,MAAK;EACd;;;;EAKO,QAAK;AACR,SAAK,UAAU;AACf,SAAK,OAAO;AAEZ,SAAK,OAAO;AACZ,SAAK,UAAU;AACf,SAAK,WAAW;AAEhB,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,qBAAqB;EAC9B;;;;EAOA,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;EAEA,IAAW,KAAK,OAAa;AACzB,SAAK,QAAQ;EACjB;;;;EAOA,IAAW,UAAO;AACd,WAAO,KAAK;EAChB;EAEA,IAAW,QAAQ,OAAa;AAC5B,SAAK,WAAW;EACpB;;;;EAOA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;EAEA,IAAW,SAAS,OAAa;AAC7B,SAAK,YAAY;EACrB;;;;EAOA,IAAW,gBAAa;AACpB,WAAO,KAAK;EAChB;EAEA,IAAW,cAAc,OAAa;AAClC,SAAK,iBAAiB;EAC1B;;;;EAOA,IAAW,cAAW;AAClB,WAAO,KAAK;EAChB;EAEA,IAAW,YAAY,OAAa;AAChC,SAAK,eAAe;EACxB;;;;EAOA,IAAW,qBAAkB;AACzB,WAAO,KAAK;EAChB;EAEA,IAAW,mBAAmB,OAAa;AACvC,SAAK,sBAAsB;EAC/B;;;;EAOA,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;EAEA,IAAW,KAAK,OAAa;AACzB,SAAK,QAAQ;EACjB;;;;EAOA,IAAW,UAAO;AACd,WAAO,KAAK;EAChB;EAEA,IAAW,QAAQ,OAAc;AAC7B,SAAK,WAAW;EACpB;;;;;EAMO,eAAY;AACf,WAAO;EACX;;;;;EAMO,OAAO,cAAkC;AAC5C,wBAAoB,MAAM,MAAM,cAAc,IAAI;EACtD;;;;;EAMO,YAAS;AACZ,WAAO,oBAAoB,UAAU,IAAI;EAC7C;;;;;;;EAQO,MAAM,QAAa,OAAc,SAAe;AACnD,wBAAoB,MAAM,MAAM,MAAM,QAAQ,OAAO,OAAO;EAChE;;AAnIA,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;AAcV,WAAA;EADC,UAAS;;;;AC7CR,IAAO,WAAP,MAAO,UAAQ;;EA6JjB,IAAW,oBAAiB;AACxB,WAAO;EACX;;EAGA,IAAW,iBAAiB,OAAc;EAE1C;;;;EAKA,IAAW,iBAAc;AACrB,WAAO,KAAK;EAChB;;;;EA0DA,IAAW,iBAAc;AAGrB,WAAO;EACX;;;;EAiBA,IAAW,MAAM,OAAa;AAC1B,QAAI,KAAK,WAAW,OAAO;AACvB;IACJ;AAEA,UAAM,WAAW,KAAK;AACtB,SAAK,SAAS;AAGd,QAAI,aAAa,KAAK,UAAU,GAAG;AAC/B,WAAK,YAAY,UAAS,gBAAgB,UAAS,gBAAgB;IACvE;EACJ;;;;EAKA,IAAW,QAAK;AACZ,WAAO,KAAK;EAChB;;;;EAWA,IAAW,gBAAgB,OAAc;AACrC,QAAI,KAAK,qBAAqB,OAAO;AACjC;IACJ;AACA,SAAK,mBAAmB;AACxB,SAAK,YAAY,UAAS,gBAAgB;EAC9C;;;;EAKA,IAAW,kBAAe;AACtB,WAAO,KAAK;EAChB;;;;EAWA,IAAW,cAAc,OAAc;AACnC,QAAI,KAAK,mBAAmB,OAAO;AAC/B;IACJ;AACA,SAAK,iBAAiB;AACtB,SAAK,YAAY,UAAS,gBAAgB;EAC9C;;;;EAKA,IAAW,gBAAa;AACpB,WAAO,KAAK;EAChB;;;;;EAQA,IAAW,sBAAmB;AAC1B,WAAO,KAAK;EAChB;EAEA,IAAW,oBAAoB,OAAc;AACzC,QAAI,KAAK,yBAAyB,OAAO;AACrC;IACJ;AAEA,SAAK,uBAAuB;AAE5B,QAAI,CAAC,OAAO;AACR,WAAK,UAAS;IAClB;EACJ;;;;;;;EAQO,sBAAsB,UAAkC;AAC3D,SAAK,sBAAsB;AAC3B,QAAI;AACA,eAAS,IAAI;IACjB;AACI,WAAK,sBAAsB;IAC/B;EACJ;;;;EA0BA,IAAW,0BAAuB;AAC9B,SAAK,WAAW,0BAA0B;AAC1C,SAAK,4CAA4C,KAAK,UAAU;AAChE,WAAO,KAAK,WAAW;EAC3B;;;;EA+BA,IAAW,UAAU,UAAoB;AACrC,QAAI,KAAK,oBAAoB;AACzB,WAAK,oBAAoB,OAAO,KAAK,kBAAkB;IAC3D;AACA,SAAK,qBAAqB,KAAK,oBAAoB,IAAI,QAAQ;EACnE;;;;EAOA,IAAW,mBAAgB;AACvB,QAAI,CAAC,KAAK,mBAAmB;AACzB,WAAK,oBAAoB,IAAI,WAAU;IAC3C;AAEA,WAAO,KAAK;EAChB;;;;EAUA,IAAW,OAAO,UAAsC;AACpD,QAAI,KAAK,iBAAiB;AACtB,WAAK,iBAAiB,OAAO,KAAK,eAAe;IACrD;AACA,SAAK,kBAAkB,KAAK,iBAAiB,IAAI,QAAQ;EAC7D;;;;EAKA,IAAW,qBAAkB;AACzB,QAAI,CAAC,KAAK,qBAAqB;AAC3B,WAAK,sBAAsB,IAAI,WAAU;IAC7C;AAEA,WAAO,KAAK;EAChB;;;;EAOA,IAAW,4BAAyB;AAChC,QAAI,CAAC,KAAK,4BAA4B;AAClC,WAAK,6BAA6B,IAAI,WAAU;IACpD;AAEA,WAAO,KAAK;EAChB;;;;;;;;;;;;;;;;;;;EA0BA,IAAW,UAAU,OAAa;AAC9B,QAAI,KAAK,eAAe,OAAO;AAC3B;IACJ;AACA,SAAK,aAAa;AAClB,SAAK,YAAY,UAAS,gBAAgB;EAC9C;;;;EAKA,IAAW,YAAS;AAChB,WAAO,KAAK;EAChB;;;;EAWA,IAAW,iBAAiB,OAAc;AACtC,QAAI,KAAK,sBAAsB,OAAO;AAClC;IACJ;AACA,SAAK,oBAAoB;AACzB,QAAI,KAAK,mBAAmB;AACxB,WAAK,wBAAwB;IACjC;EACJ;;;;EAKA,IAAW,mBAAgB;AACvB,WAAO,KAAK;EAChB;;;;EAKA,IAAW,mBAAgB;AACvB,WAAO;EACX;;;;EAyCA,IAAW,WAAW,OAAc;AAChC,QAAI,KAAK,gBAAgB,OAAO;AAC5B;IACJ;AACA,SAAK,cAAc;AACnB,SAAK,YAAY,UAAS,aAAa;EAC3C;;;;EAKA,IAAW,aAAU;AACjB,WAAO,KAAK;EAChB;EAoBA,IAAW,YAAS;AAChB,YAAQ,KAAK,WAAW;MACpB,KAAK,UAAS;MACd,KAAK,UAAS;MACd,KAAK,UAAS;MACd,KAAK,UAAS;AACV,eAAO;IACf;AAEA,WAAO,KAAK,OAAO;EACvB;;;;EAKA,IAAW,UAAU,OAAc;AAC/B,SAAK,WAAW,QAAQ,UAAS,oBAAoB,UAAS;EAClE;;;;EAMA,IAAW,cAAW;AAClB,YAAQ,KAAK,WAAW;MACpB,KAAK,UAAS;MACd,KAAK,UAAS;AACV,eAAO;IACf;AAEA,WAAO,KAAK,OAAO;EACvB;;;;EAKA,IAAW,YAAY,OAAc;AACjC,SAAK,WAAW,QAAQ,UAAS,gBAAgB,UAAS;EAC9D;;;;EAMA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;;;;EAKA,IAAW,SAAS,OAAa;AAC7B,QAAI,KAAK,cAAc,OAAO;AAC1B;IACJ;AAEA,SAAK,YAAY;AACjB,SAAK,YAAY,UAAS,aAAa;EAC3C;;;;;;EA6CA,IAAW,sBAAmB;AAC1B,WAAO,KAAK;EAChB;EAEA,IAAW,oBAAoB,OAAc;AACzC,UAAM,yBAAyB,KAAK,SAAQ,EAAG,UAAS,EAAG,QAAO,EAAG;AAErE,QAAI,SAAS,CAAC,wBAAwB;AAClC,aAAO,KAAK,0FAA0F;IAC1G;AAEA,SAAK,uBAAuB,SAAS;AAErC,SAAK,6BAA4B;EACrC;;EAUO,kBAAe;AAClB,WAAO,KAAK;EAChB;;;;EAIO,gBAAgB,aAAwB;AAC3C,SAAK,eAAe;EACxB;;;;;;;;EAuGA,YAAY,MAAc,OAAyB,UAAoB,YAAY,OAAK;AA1sBjF,SAAA,qBAAmD;AAOnD,SAAA,yBAAyB;AAGtB,SAAA,kBAAe;AAEf,SAAA,aAAa;AA4ChB,SAAA,WAAgB;AAQhB,SAAA,oBAAyB;AAMzB,SAAA,wBAAwB;AAMxB,SAAA,qBAAqB;AAMrB,SAAA,QAAQ;AAeL,SAAA,SAAS;AAoCT,SAAA,mBAAmB;AAwBnB,SAAA,iBAAiB;AAoBnB,SAAA,uBAAuB;AAyCxB,SAAA,kBAAoC;AAKpC,SAAA,aAAiD;AAKjD,SAAA,UAA8D;AAK9D,SAAA,0BAA2E;AAc3E,SAAA,iBAAiB;AAKjB,SAAA,0BAA0B;AAK1B,SAAA,aAAyC;AAKzC,SAAA,sBAAsB,IAAI,WAAU;AAKnC,SAAA,qBAAmD;AACnD,SAAA,sBAAsD;AA4BtD,SAAA,kBAAoD;AAwCpD,SAAA,aAAqB;AAuCrB,SAAA,oBAAoB;AAiCrB,SAAA,oBAAoB;AAMpB,SAAA,oBAAoB;AAMpB,SAAA,kBAAkB;AAMlB,SAAA,gBAAgB;AAMhB,SAAA,sBAAsB;AAMrB,SAAA,cAAc;AAwBf,SAAA,YAAY;AAMZ,SAAA,UAAU;AAMV,SAAA,eAAe;AA+FN,SAAA,UAAU,IAAI,qBAAoB;AA+C1C,SAAA,UAAmB;AAWnB,SAAA,YAAY,UAAS;AAKrB,SAAA,yBAAkC;AAKlC,SAAA,yBAAkC;AAKlC,SAAA,4BAAoC;AASrC,SAAA,6BAA6B;AAG7B,SAAA,UAAgE;AAGhE,SAAA,mBAA8C;AAM9C,SAAA,4BAA4B;AAEzB,SAAA,aAa6B,CAAA;AAGhC,SAAA,8BAUK,MAAM;AAEX,SAAA,wCAA8F,MAAM;AAEpG,SAAA,qCAAwF,MAAM;AAE9F,SAAA,qDAAwG,MAAM;AAE9G,SAAA,yCAAgG,MAAM;AAEtG,SAAA,qCAAwF,MAAM;AAE9F,SAAA,8CAA0G,MAAM;AAEhH,SAAA,+CAA4G,MAAM;AAyK/G,SAAA,oBAAsC;AA/J5C,SAAK,OAAO;AACZ,UAAM,WAAW,SAAS,YAAY;AACtC,QAAI,CAAC,UAAU;AACX;IACJ;AACA,SAAK,SAAS;AACd,SAAK,kBAAkB,CAAA;AACvB,SAAK,aAAa;AAElB,SAAK,gBAAgB,CAAA,IAAA,KAAU,iCAAiC,KAAC,IAAA;AACjE,SAAK,gBAAgB,CAAA,IAAA,KAAU,+BAA+B,KAAC,IAAA;AAC/D,SAAK,gBAAgB,CAAA,IAAA,KAAU,gCAA6B,KAAK,IAAA;AACjE,SAAK,gBAAgB,CAAA,IAAA,KAAU,mCAAgC,KAAK,IAAA;AACpE,SAAK,gBAAgB,EAAA,IAAA,KAAU,6BAA8B,KAAC,IAAA;AAC9D,SAAK,gBAAgB,EAAA,IAAA,KAAU,gCAAiC,KAAC,IAAA;AACjE,SAAK,gBAAgB,GAAA,IAAA,KAAU,4BAA8B,KAAA,IAAA;AAE7D,SAAK,KAAK,QAAQ,MAAM,SAAQ;AAChC,SAAK,WAAW,KAAK,OAAO,YAAW;AACvC,SAAK,mBAAmB,KAAK,OAAO,UAAS,EAAG,sBAAqB;AACrE,SAAK,eAAe,IAAI,YAAY,KAAK,OAAO,UAAS,GAAI,KAAK;AAClE,SAAK,aAAa,kBAAkB,KAAK;AAEzC,SAAK,iBAAiB,IAAI,cAAc,KAAK,OAAO,UAAS,GAAI,QAAW,QAAW,IAAI;AAC3F,SAAK,UAAU,KAAK,SAAQ,EAAG,UAAS,EAAG;AAE3C,SAAK,qBAAoB;AAEzB,QAAI,CAAC,UAAU;AACX,WAAK,OAAO,YAAY,IAAI;IAChC;AAEA,QAAI,KAAK,OAAO,oBAAoB;AAChC,WAAK,UAAU,CAAA;IACnB;AAEA,cAAS,kBAAkB;MAAgB;MAAI;;IAAA;EACnD;;EAGO,uBAAoB;;AACvB,UAAM,SAAS,KAAK,SAAQ,EAAG,UAAS;AAExC,eAAK,mBAAL,mBAAqB;AAErB,QAAI,OAAO,YAAY,CAAC,KAAK,YAAY;AAErC,WAAK,iBAAiB,IAAI,cAAc,QAAQ,QAAW,QAAW,KAAK,MAAM,IAAI;AACrF,WAAK,kBAAe;IACxB,OAAO;AACH,WAAK,iBAAiB,IAAI,cAAc,KAAK,OAAO,UAAS,GAAI,QAAW,QAAW,KAAK,IAAI;IACpG;AAEA,SAAK,4BAA4B;EACrC;;;;;;;EAQO,SAAS,aAAqB;AACjC,UAAM,MAAM,WAAW,KAAK;AAC5B,WAAO;EACX;;;;;EAMO,eAAY;AACf,WAAO;EACX;;EAGA,IAAW,cAAW;AAClB,WAAO;EACX;;;;EAKA,IAAW,WAAQ;AACf,WAAO,KAAK;EAChB;;;;EAKO,SAAM;AACT,SAAK,UAAS;AACd,SAAK,qBAAqB;EAC9B;;;;EAKO,WAAQ;AACX,SAAK,UAAS;AACd,SAAK,qBAAqB;EAC9B;;;;;;;;EASO,QAAQ,MAAqB,cAAsB;AACtD,WAAO;EACX;;;;;;;;;EAUO,kBAAkB,MAAoB,SAAkB,cAAsB;AACjF,UAAM,UAAU,QAAQ;AACxB,QAAI,CAAC,SAAS;AACV,aAAO;IACX;AAEA,SAAK,WAAW,oBAAoB;AACpC,SAAK,WAAW,UAAU;AAC1B,SAAK,sCAAsC,KAAK,UAAU;AAE1D,WAAO,KAAK,WAAW;EAC3B;;;;;EAMO,YAAS;AACZ,WAAO,KAAK,aAAa;EAC7B;;;;;EAMO,WAAQ;AACX,WAAO,KAAK;EAChB;;EAGO,yBAAyB,MAAU;AACtC,WAAO,KAAK,oBAAoB,OAAO,KAAK,kBAAkB,KAAK;EACvE;;;;EAWA,IAAW,mBAAgB;AACvB,WAAO,KAAK;EAChB;;;;;;;;;;;;EAaA,IAAW,iBAAiB,OAAuB;AAC/C,QAAI,KAAK,sBAAsB,OAAO;AAClC;IACJ;AAEA,SAAK,oBAAoB;AAEzB,SAAK,wCAAuC;EAChD;EAEA,IAAc,uBAAoB;AAC9B,WAAO,KAAK,qBAAqB;EACrC;EAEA,IAAc,2BAAwB;AAClC,WAAO,KAAK,sBAAsB,UAAS,uBAAuB,KAAK,sBAAsB,UAAS;EAC1G;EAEA,IAAc,0BAAuB;AACjC,WAAO,KAAK,sBAAsB,UAAS,sBAAsB,KAAK,sBAAsB,UAAS;EACzG;;;;EAKA,IAAc,wBAAqB;AAC/B,WAAO,KAAK,sBAAsB,UAAS,mBAAmB,KAAK,sBAAsB,UAAS;EACtG;;;;;;EAOO,oBAAiB;AACpB,QAAI,KAAK,sBAAsB;AAC3B,aAAO,KAAK;IAChB;AAEA,QAAI,KAAK,uBAAuB;AAC5B,aAAO;IACX;AAEA,WAAO,KAAK,QAAQ;EACxB;;;;;;EAOO,yBAAyB,MAAkB;AAC9C,QAAI,KAAK,sBAAsB;AAC3B,aAAO,KAAK;IAChB;AAEA,QAAI,KAAK,aAAa,GAAK;AACvB,aAAO;IACX;AAEA,QAAI,KAAK,uBAAuB;AAC5B,aAAO;IACX;AAEA,WAAO,KAAK,kBAAkB,KAAK,kBAAiB;EACxD;;;;;;EAOO,mBAAgB;AACnB,QAAI,KAAK,sBAAsB;AAC3B,aAAO,KAAK;IAChB;AAEA,WAAO;EACX;;;;;;EAOO,wBAAwB,MAAkB;AAC7C,QAAI,KAAK,sBAAsB;AAC3B,aAAO,KAAK;IAChB;AAEA,WAAO,CAAC,KAAK,yBAAyB,IAAI,KAAK,KAAK,iBAAgB;EACxE;;;;;EAMO,sBAAmB;AACtB,WAAO;EACX;;;;;EAMO,UAAU,qBAAqB,OAAK;AACvC,UAAM,SAAS,KAAK,SAAQ,EAAG;AAC/B,eAAW,QAAQ,QAAQ;AACvB,UAAI,CAAC,KAAK,WAAW;AACjB;MACJ;AACA,iBAAW,WAAW,KAAK,WAAW;AAClC,YAAI,QAAQ,YAAW,MAAO,MAAM;AAChC;QACJ;AAEA,mBAAW,eAAe,QAAQ,eAAe;AAC7C,cAAI,CAAC,aAAa;AACd;UACJ;AACA,cAAI,KAAK,qBAAqB,YAAY,iBAAiB;AACvD,wBAAY,sBAAsB;AAClC,wBAAY,+BAA+B;AAC3C,wBAAY,yBAAyB;UACzC;QACJ;MACJ;IACJ;AAEA,QAAI,oBAAoB;AACpB,WAAK,YAAY,UAAS,YAAY;IAC1C;EACJ;;;;EAKO,SAAS,QAA+B,sBAAwC,MAAI;AACvF,UAAM,SAAS,KAAK,OAAO,UAAS;AAEpC,UAAM,cAAc,uBAAuB,OAAO,KAAK,kBAAkB;AACzE,UAAM,UAAU,gBAAgB,UAAS;AAEzC,WAAO,aAAa,SAAS,SAAS,KAAK,gBAAe,CAAE;AAC5D,WAAO,SACH,KAAK,iBACL,KAAK,SACL,OACA,SACA,KAAK,OAAO,0BAA0B,CAAC,KAAK,gBAAgB,KAAK,eACjE,KAAK,SACL,KAAK,YAAY;AAGrB,WAAO;EACX;;;;;;;EAQO,KAAK,OAAe,MAAW;EAAS;;;;EAKxC,qBAAkB;AACrB,UAAM,MAAM,KAAK;AAEjB,SAAK,WAAW,MAAM;AACtB,SAAK,4BAA2B,GAA2C,KAAK,UAAU;AAE1F,QAAI,OAAM;AAEV,SAAK,4BAA4B;EACrC;;;;;;;EAQO,eAAe,OAAe,MAAY,SAAgB;AAC7D,UAAM,cAAc,QAAQ;AAE5B,SAAK,WAAW,UAAU;AAC1B,SAAK,mCAAmC,KAAK,UAAU;AACvD,gBAAY,yBAAyB;EACzC;;;;;;EAOO,oBAAoB,OAAa;EAAS;;;;;EAM1C,SAAS,QAAc;AAC1B,QAAI,CAAC,KAAK,SAAS;AACf,aAAO,UAAU,QAAQ,KAAK,SAAQ,EAAG,cAAa,CAAE;IAC5D,OAAO;AACH,WAAK,sBAAsB;IAC/B;EACJ;;;;;EAMO,mBAAmB,QAAc;AACpC,QAAI,CAAC,KAAK,SAAS;AACf,aAAO,UAAU,kBAAkB,KAAK,SAAQ,EAAG,mBAAkB,CAAE;AACvE,aAAO,UAAU,cAAc,KAAK,SAAQ,EAAG,oBAAmB,CAAE;IACxE,OAAO;AACH,WAAK,sBAAsB;IAC/B;EACJ;;;;;;EAOO,gBAAgB,QAAgB,cAAqB;AACxD,QAAI,CAAC,KAAK,SAAS;AACf,WAAK,OAAO,gBAAgB,QAAQ,YAAY;IACpD,OAAO;AACH,WAAK,sBAAsB;IAC/B;EACJ;;;;;;;EAQU,WAAW,MAAqB,SAA2B,MAAM,UAAkB;AACzF,SAAK,OAAO,kBAAkB;AAC9B,QAAI,KAAK,qBAAqB;AAC1B,UAAI,QAAQ;AACR,aAAK,sBAAsB;AAC3B,+BAAuB,QAAQ,KAAK,SAAQ,EAAG,sBAAqB,CAAE;AACtE,aAAK,OAAO,iBAAgB;MAChC;IACJ;AACA,QAAI,MAAM;AACN,WAAK,OAAO,oBAAoB,KAAK;IACzC,OAAO;AACH,WAAK,OAAO,oBAAoB;IACpC;AAEA,QAAI,KAAK,qBAAqB,MAAM;AAChC,WAAK,kBAAkB,gBAAgB,IAAI;IAC/C;AAEA,QAAI,KAAK,mBAAmB;AACxB,YAAM,SAAS,KAAK,OAAO,UAAS;AACpC,WAAK,yBAAyB,OAAO,cAAa;AAClD,aAAO,cAAc,KAAK;IAC9B;AAEA,QAAI,KAAK,mBAAmB;AACxB,YAAM,SAAS,KAAK,OAAO,UAAS;AACpC,WAAK,yBAAyB,OAAO,cAAa;AAClD,aAAO,cAAc,KAAK;IAC9B;AAEA,QAAI,KAAK,kBAAkB,GAAG;AAC1B,YAAM,SAAS,KAAK,OAAO,UAAS;AACpC,WAAK,4BAA4B,OAAO,iBAAgB,KAAM;AAC9D,aAAO,iBAAiB,KAAK,aAAa;IAC9C;EACJ;;;;EAKO,SAAM;AACT,SAAK,OAAO,sBAAqB,EAAG,aAAY;AAEhD,QAAI,KAAK,qBAAqB;AAC1B,WAAK,oBAAoB,gBAAgB,IAAI;IACjD;AAEA,QAAI,KAAK,kBAAkB,GAAG;AAC1B,YAAM,SAAS,KAAK,OAAO,UAAS;AACpC,aAAO,iBAAiB,KAAK,yBAAyB;IAC1D;AAEA,QAAI,KAAK,mBAAmB;AACxB,YAAM,SAAS,KAAK,OAAO,UAAS;AACpC,aAAO,cAAc,KAAK,sBAAsB;IACpD;AAEA,QAAI,KAAK,mBAAmB;AACxB,YAAM,SAAS,KAAK,OAAO,UAAS;AACpC,aAAO,cAAc,KAAK,sBAAsB;IACpD;EACJ;;;;;EAMO,iBAAc;AACjB,SAAK,WAAW,cAAc,CAAA;AAC9B,SAAK,4BAA2B,KAAqC,KAAK,UAAU;AACpF,WAAO,KAAK,WAAW;EAC3B;;;;;EAMO,oBAAiB;AACpB,SAAK,WAAW,iBAAiB,CAAA;AACjC,SAAK,4BAA2B,KAAwC,KAAK,UAAU;AACvF,WAAO,KAAK,WAAW;EAC3B;;;;;;EAOO,WAAW,SAAoB;AAClC,SAAK,WAAW,aAAa;AAC7B,SAAK,WAAW,UAAU;AAC1B,SAAK,4BAA2B,MAAiC,KAAK,UAAU;AAChF,WAAO,KAAK,WAAW;EAC3B;;;;;;;EAQO,MAAM,MAAY;AACrB,WAAO;EACX;EAEU,cAAc,gBAA0B,SAAe;AAC7D,UAAM,sBAA2B,CAAA;AAGjC,SAAK,kBAAkB,mBAAmB;AAE1C,cAAS,cAAc,qBAAqB,gBAAgB,KAAK,QAAQ,OAAO;AAGhF,QAAI,KAAK,eAAe;AACpB,iBAAW,UAAU,KAAK,cAAc,UAAU;AAC9C,cAAM,eAAe,eAAe,cAAe,UAAU,OAAO,IAAI;AACxE,YAAI,cAAc;AACd,iBAAO,OAAO,YAAY;QAC9B;MACJ;IACJ;EACJ;;;;;EAMO,kBAAe;AAClB,QAAI,KAAK,SAAS;AACd,YAAM,SAAyB,CAAA;AAC/B,iBAAW,UAAU,KAAK,SAAS;AAC/B,cAAM,OAAO,KAAK,QAAQ,MAAM;AAChC,YAAI,MAAM;AACN,iBAAO,KAAK,IAAI;QACpB;MACJ;AACA,aAAO;IACX,OAAO;AACH,YAAM,SAAS,KAAK,OAAO;AAC3B,aAAO,OAAO,OAAO,CAAC,SAAS,KAAK,aAAa,IAAI;IACzD;EACJ;;;;;;;;EASO,iBACH,MACA,YACA,SACA,SAAkC;AAElC,UAAM,eAAe;MACjB,WAAW;MACX,cAAc;MACd,GAAG;;AAGP,UAAM,QAAQ,KAAK,SAAQ;AAC3B,UAAM,yBAAyB,KAAK;AACpC,SAAK,yBAAyB;AAE9B,UAAM,aAAa,MAAK;AACpB,UAAI,CAAC,KAAK,UAAU,CAAC,KAAK,OAAO,UAAS,GAAI;AAC1C;MACJ;AAEA,YAAM,iBAAiB,MAAM;AAE7B,UAAI,aAAa,WAAW;AACxB,cAAM,YAAY,IAAI,MAAM,GAAG,GAAG,GAAG,CAAC;MAC1C;AAEA,UAAI,KAAK,yBAAyB;AAC9B,YAAI,UAAU,MACV,YAAY;AAChB,YAAI,KAAK,WAAW;AAChB,gBAAM,cAAc,IAAI,QAAQ,GAAG,GAAG,GAAG,GAAG,GAAG,MAAM,QAAW,OAAO,KAAK;AAC5E,cAAI,YAAY,iBAAiB;AAC7B,wBAAY,gBAAgB,YAAY;UAC5C;AACA,cAAI,CAAC,KAAK,kBAAkB,MAAM,aAAa,aAAa,YAAY,GAAG;AACvE,gBAAI,YAAY,UAAU,YAAY,OAAO,oBAAmB,KAAM,YAAY,OAAO,sBAAqB,GAAI;AAC9G,0BAAY,YAAY,OAAO,oBAAmB;YACtD,OAAO;AACH,wBAAU;AACV,yBAAW,YAAY,EAAE;YAC7B;UACJ;QACJ;AACA,YAAI,SAAS;AACT,eAAK,yBAAyB;AAC9B,cAAI,WAAW;AACX,gBAAI,SAAS;AACT,sBAAQ,SAAS;YACrB;UACJ;AACA,cAAI,YAAY;AACZ,uBAAW,IAAI;UACnB;QACJ;MACJ,OAAO;AACH,YAAI,KAAK,QAAO,GAAI;AAChB,eAAK,yBAAyB;AAC9B,cAAI,YAAY;AACZ,uBAAW,IAAI;UACnB;QACJ,OAAO;AACH,qBAAW,YAAY,EAAE;QAC7B;MACJ;AAEA,UAAI,aAAa,WAAW;AACxB,cAAM,YAAY;MACtB;IACJ;AAEA,eAAU;EACd;;;;;;;EAQO,sBAAsB,MAAoB,SAA8C;AAC3F,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,WAAK,iBACD,MACA,MAAK;AACD,gBAAO;MACX,GACA,SACA,CAAC,WAAU;AACP,eAAO,MAAM;MACjB,CAAC;IAET,CAAC;EACL;;;;;EAgCO,YAAY,MAAY;AAC3B,QAAI,KAAK,SAAQ,EAAG,+BAA+B,KAAK,sBAAsB;AAC1E;IACJ;AAEA,cAAS,oBAAoB,SAAS;AAEtC,QAAI,OAAO,UAAS,0BAA0B;AAC1C,gBAAS,oBAAoB,KAAK,UAAS,6BAA6B;IAC5E;AAEA,QAAI,OAAO,UAAS,kBAAkB;AAClC,gBAAS,oBAAoB,KAAK,UAAS,qBAAqB;IACpE;AAEA,QAAI,OAAO,UAAS,gBAAgB;AAChC,gBAAS,oBAAoB,KAAK,UAAS,oBAAoB;IACnE;AAEA,QAAI,OAAO,UAAS,kBAAkB;AAClC,gBAAS,oBAAoB,KAAK,UAAS,qBAAqB;IACpE;AAEA,QAAI,OAAO,UAAS,qBAAqB;AACrC,gBAAS,oBAAoB,KAAK,UAAS,uBAAuB;IACtE;AAEA,QAAI,OAAO,UAAS,eAAe;AAC/B,gBAAS,oBAAoB,KAAK,UAAS,kBAAkB;IACjE;AAEA,QAAI,OAAO,UAAS,kBAAkB;AAClC,gBAAS,oBAAoB,KAAK,UAAS,qBAAqB;IACpE;AAEA,QAAI,UAAS,oBAAoB,QAAQ;AACrC,WAAK,yBAAyB,UAAS,kBAAkB;IAC7D;AAEA,SAAK,SAAQ,EAAG,oBAAmB;EACvC;;;;EAKO,iBAAc;AACjB,UAAM,SAAS,KAAK,SAAQ,EAAG;AAC/B,eAAW,QAAQ,QAAQ;AACvB,UAAI,CAAC,KAAK,WAAW;AACjB;MACJ;AACA,iBAAW,WAAW,KAAK,WAAW;AAClC,YAAI,QAAQ,YAAW,MAAO,MAAM;AAChC;QACJ;AAEA,gBAAQ,eAAc;MAC1B;IACJ;EACJ;;;;;EAMU,yBAAyB,MAAwC;AACvE,UAAM,QAAQ,KAAK,SAAQ;AAC3B,QAAI,MAAM,+BAA+B,KAAK,sBAAsB;AAChE;IACJ;AAEA,UAAM,SAAS,MAAM;AACrB,eAAW,QAAQ,QAAQ;AACvB,UAAI,CAAC,KAAK,WAAW;AACjB;MACJ;AACA,iBAAW,WAAW,KAAK,WAAW;AAElC,cAAM,WAAW,QAAQ,YAAW,MAAO,MAAM,sBAAsB,MAAM,kBAAkB;AAC/F,YAAI,aAAa,MAAM;AACnB;QACJ;AAEA,mBAAW,eAAe,QAAQ,eAAe;AAC7C,cAAI,CAAC,eAAe,CAAC,YAAY,WAAW,CAAE,YAAY,QAA4B,gBAAgB;AAClG;UACJ;AACA,cAAI,KAAK,qBAAqB,YAAY,iBAAiB;AACvD,iBAAK,YAAY,OAA0B;UAC/C;QACJ;MACJ;IACJ;EACJ;;;;EAKU,yBAAsB;AAC5B,QAAI,KAAK,SAAQ,EAAG,+BAA+B,KAAK,sBAAsB;AAC1E;IACJ;AAEA,UAAM,kBAAkB,KAAK,SAAQ,EAAG,sBAAqB;AAC7D,QAAI,iBAAiB;AACjB,sBAAgB,YAAW;IAC/B;EACJ;;;;EAKU,8BAA2B;AACjC,SAAK,yBAAyB,UAAS,iBAAiB;EAC5D;;;;EAKU,0CAAuC;AAC7C,SAAK,yBAAyB,UAAS,6BAA6B;EACxE;;;;EAKU,mCAAgC;AACtC,SAAK,yBAAyB,UAAS,qBAAqB;EAChE;;;;EAKU,kCAA+B;AACrC,SAAK,yBAAyB,UAAS,qBAAqB;EAChE;;;;EAKU,yCAAsC;AAC5C,SAAK,yBAAyB,UAAS,4BAA4B;EACvE;;;;EAKU,iCAA8B;AACpC,SAAK,yBAAyB,UAAS,oBAAoB;EAC/D;;;;EAKU,qCAAkC;AACxC,SAAK,yBAAyB,UAAS,uBAAuB;EAClE;;;;EAKU,+BAA4B;AAClC,SAAK,yBAAyB,UAAS,kBAAkB;EAC7D;;;;EAKU,kCAA+B;AACrC,SAAK,yBAAyB,UAAS,qBAAqB;EAChE;;;;EAKU,0CAAuC;AAC7C,SAAK,yBAAyB,UAAS,4BAA4B;EACvE;EAEU,iCAA8B;AACpC,QAAI,KAAK,OAAO,wBAAmB,GAAkD;AACjF,WAAK,qBAAqB;AAE1B,YAAM,WAAW,KAAK,OAAO,4CAA4C,QAAQ,MAAK;AAClF,aAAK,qBAAqB;MAC9B,CAAC;AAED,WAAK,oBAAoB,IAAI,MAAK;AAC9B,aAAK,OAAO,4CAA4C,OAAO,QAAQ;MAC3E,CAAC;IACL;EACJ;;;;;;;EAQO,mBAAmB,iBAAgC;AAEtD,WAAO;EACX;;;;;;;EAQO,QAAQ,qBAA+B,sBAAgC,gBAAwB;AAClG,UAAM,QAAQ,KAAK,SAAQ;AAE3B,UAAM,cAAc,IAAI;AACxB,UAAM,uBAAsB;AAG5B,UAAM,eAAe,IAAI;AAEzB,SAAK,WAAW,uBAAuB;AACvC,SAAK,4BAA2B,GAA+B,KAAK,UAAU;AAE9E,QAAI,KAAK,kBAAkB;AACvB,YAAM,QAAQ,KAAK,iBAAiB,UAAU,QAAQ,IAAI;AAC1D,UAAI,QAAQ,IAAI;AACZ,aAAK,iBAAiB,UAAU,OAAO,OAAO,CAAC;MACnD;AACA,WAAK,mBAAmB;IAC5B;AAEA,QAAI,mBAAmB,MAAM;AAEzB,UAAI,KAAK,SAAS;AACd,mBAAW,UAAU,KAAK,SAAS;AAC/B,gBAAM,OAAO,KAAK,QAAQ,MAAM;AAChC,eAAK,sBAAsB,IAAI;QACnC;MACJ,OAAO;AACH,cAAM,SAAS,MAAM;AACrB,mBAAW,QAAQ,QAAQ;AACvB,eAAK,sBAAsB,IAAI;QACnC;MACJ;IACJ;AAEA,SAAK,eAAe,QAAO;AAG3B,QAAI,KAAK,aAAa,QAAQ;AAC1B,UAAI,CAAC,KAAK,yBAAyB;AAC/B,aAAK,aAAa,OAAO,QAAO;MACpC;AAEA,WAAK,aAAa,SAAS;IAC/B;AAEA,SAAK,WAAW;AAGhB,SAAK,oBAAoB,gBAAgB,IAAI;AAE7C,SAAK,oBAAoB,MAAK;AAC9B,QAAI,KAAK,mBAAmB;AACxB,WAAK,kBAAkB,MAAK;IAChC;AAEA,QAAI,KAAK,qBAAqB;AAC1B,WAAK,oBAAoB,MAAK;IAClC;AAEA,QAAI,KAAK,4BAA4B;AACjC,WAAK,2BAA2B,MAAK;IACzC;AAEA,QAAI,KAAK,YAAY;AACjB,WAAK,aAAa,CAAA;IACtB;EACJ;EAEQ,sBAAsB,MAA8B;;AACxD,QAAI,CAAC,MAAM;AACP;IACJ;AAEA,UAAM,WAAkB,KAAM;AAC9B,UAAM,wBAAwB,KAAK,8BAA8B;AACjE,QAAI,KAAK,yBAAyB;AAC9B,UAAI,KAAK,aAAa,uBAAuB;AACzC,mBAAW,WAAW,KAAK,WAAW;AAClC,gBAAM,eAAe,QAAQ;AAC7B,mBAAS,kBAAkB,GAAG,kBAAkB,aAAa,QAAQ,mBAAmB;AACpF,kBAAM,UAAS,kBAAa,eAAe,MAA5B,mBAA+B;AAC9C,gBAAI,CAAC,QAAQ;AACT;YACJ;AACA,kBAAM,WAAW,sBAAsB,eAAe;AACtD,gBAAI,aAAa,MAAM;AACnB,mDAAU,0BAA0B;AACpC,sBAAQ,mBAAmB,iBAAiB,MAAM,IAAI;YAC1D;UACJ;QACJ;MACJ;IACJ,OAAO;AACH,2CAAU,0BAA0B,KAAK,aAAa;IAC1D;AAEA,QAAI,KAAK,aAAa,QAAQ,CAAE,KAAuB,YAAY;AAC/D,WAAK,WAAW;IACpB;EACJ;;;;;EAMO,YAAS;AACZ,UAAM,sBAAsB,oBAAoB,UAAU,IAAI;AAE9D,wBAAoB,UAAU,KAAK,QAAQ,UAAS;AACpD,wBAAoB,WAAW,KAAK;AAEpC,SAAK,kBAAkB,mBAAmB;AAE1C,WAAO;EACX;EAEU,kBAAkB,qBAAwB;AAChD,wBAAoB,UAAU,CAAA;AAE9B,QAAI,KAAK,eAAe;AACpB,iBAAW,UAAU,KAAK,cAAc,UAAU;AAC9C,YAAI,CAAC,OAAO,gBAAgB;AACxB,8BAAoB,QAAQ,OAAO,aAAY,CAAE,IAAI,OAAO,UAAS;QACzE;MACJ;IACJ;EACJ;;;;;;;;EASO,OAAO,MAAM,gBAAqB,OAAc,SAAe;AAClE,QAAI,CAAC,eAAe,YAAY;AAC5B,qBAAe,aAAa;IAChC,WAAW,eAAe,eAAe,yBAAyB,eAAe,kBAAkB;AAC/F,qBAAe,aAAa;AAC5B,UAAI,CAAC,QAAQ,mBAAmB;AAC5B,eAAO,MAAM,kHAAkH;AAC/H,eAAO;MACX;IACJ;AAEA,UAAM,eAAe,MAAM,YAAY,eAAe,UAAU;AAChE,UAAM,WAAW,aAAa,MAAM,gBAAgB,OAAO,OAAO;AAClE,aAAS,kBAAkB,eAAe;AAE1C,WAAO;EACX;EAEU,OAAO,cAAc,qBAA0B,UAAoB,OAAc,SAAe;;AACtG,QAAI,CAAC,oBAAoB,SAAS;AAC9B;IACJ;AAEA,eAAW,mBAAmB,oBAAoB,SAAS;AACvD,YAAM,aAAa,oBAAoB,QAAQ,eAAe;AAE9D,UAAI,UAAS,cAAS,kBAAT,mBAAwB,UAAU,WAAW;AAE1D,UAAI,CAAC,QAAQ;AACT,cAAM,kBAAkB,MAAM,YAAY,aAAa,eAAe;AACtE,YAAI,iBAAiB;AACjB,mBAAS,IAAI,gBAAgB,QAAQ;QACzC;MACJ;AAEA,uCAAQ,MAAM,YAAY,OAAO;IACrC;EACJ;;AAj5DuB,SAAA,mBAAmB;AAInB,SAAA,oBAAoB;AAIpB,SAAA,gBAAgB;AAIhB,SAAA,oBAAoB;AAIpB,SAAA,mBAAmB;AAInB,SAAA,mBAAmB;AAInB,SAAA,oBAAoB;AAIpB,SAAA,wBAAwB;AAIxB,SAAA,sBAAsB;AAKtB,SAAA,2BAA2B;AAK3B,SAAA,kCAAkC;AAKlC,SAAA,2BAA2B;AAK3B,SAAA,mBAAmB;AAKnB,SAAA,iBAAiB;AAKjB,SAAA,mBAAmB;AAKnB,SAAA,sBAAsB;AAKtB,SAAA,gBAAgB;AAKhB,SAAA,mBAAmB;AAKnB,SAAA,eAAe;AAKf,SAAA,kBAAkB;AAKlB,SAAA,qBAAqB;AAKrB,SAAA,sBAAsB;AAMtB,SAAA,6BAA6B;AAM7B,SAAA,sCAAsC;AAMtC,SAAA,iCAAiC;AAK1C,SAAA,oBAAoB,IAAI,WAAU;AA43CxB,SAAA,oBAAoB,CAAC,YAA6B,QAAQ,eAAc;AACxE,SAAA,gCAAgC,CAAC,YAA6B,QAAQ,2BAA0B;AAChG,SAAA,wBAAwB,CAAC,YAA6B,QAAQ,oBAAmB;AACjF,SAAA,wBAAwB,CAAC,YAA6B,QAAQ,mBAAkB;AAChF,SAAA,qBAAqB,CAAC,YAA6B,QAAQ,gBAAe;AAC1E,SAAA,wBAAwB,CAAC,YAA6B,QAAQ,mBAAkB;AAChF,SAAA,uBAAuB,CAAC,YAA6B,QAAQ,iBAAgB;AAC7E,SAAA,0BAA0B,CAAC,YAA6B,QAAQ,sBAAqB;AAE9F,SAAA,+BAA+B,CAAC,YAA4B;AACvE,WAAS,sBAAsB,OAAO;AACtC,WAAS,mBAAmB,OAAO;AACvC;AAEe,SAAA,+BAA+B,CAAC,YAA4B;AACvE,WAAS,sBAAsB,OAAO;AACtC,WAAS,mBAAmB,OAAO;AACvC;AAEwB,SAAA,sBAAiE,CAAA;AACjE,SAAA,qBAAqB,CAAC,YAA4B;AACtE,aAAW,MAAM,SAAS,qBAAqB;AAC3C,OAAG,OAAO;EACd;AACJ;AA/1CO,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAUH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAeH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAgBA,WAAA;EADT,UAAU,OAAO;;AAqCR,WAAA;EADT,UAAU,iBAAiB;;AAyBlB,WAAA;EADT,UAAU,eAAe;;AA8DnB,WAAA;EADN,UAAS;;AAuHF,WAAA;EADP,UAAU,WAAW;;AAwCd,WAAA;EADP,UAAS;;AAkCH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOF,WAAA;EADP,UAAU,YAAY;;AAyBhB,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AAOH,WAAA;EADN,UAAS;;AA0BV,WAAA;EADC,UAAS;;AAsBV,WAAA;EADC,UAAS;;AA4DV,WAAA;EADC,UAAS;;AA8SV,WAAA;EADC,UAAS;;",
  "names": []
}
